/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-11-08 14:54:02.127310
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24;
x0=IKcos(j[0]);
x1=IKsin(j[1]);
x2=IKcos(j[2]);
x3=IKcos(j[1]);
x4=IKsin(j[2]);
x5=IKsin(j[0]);
x6=IKsin(j[3]);
x7=IKcos(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=((1.0)*x7);
x11=((0.143)*x5);
x12=((1.0)*x0);
x13=((0.098)*x0);
x14=((0.098)*x5);
x15=((0.143)*x4);
x16=((1.0)*x5);
x17=((0.143)*x0);
x18=((1.0)*x6);
x19=(x3*x4);
x20=(x2*x3);
x21=(x1*x2);
x22=(x0*x1);
x23=(x1*x5);
x24=(x1*x4);
eetrans[0]=((0.085)+(((-0.01)*x0))+((x7*((((x17*x21))+((x0*x15*x3))))))+(((0.103)*x22))+((x6*(((((-1.0)*x15*x22))+((x17*x20))))))+(((-0.015)*x5))+((x13*x21))+((x13*x19)));
eetrans[1]=((-0.01)+(((-0.01)*x5))+((x6*(((((-1.0)*x11*x24))+((x11*x20))))))+((x14*x19))+((x14*x21))+((x7*((((x11*x21))+((x11*x19))))))+(((0.015)*x0))+(((0.103)*x23)));
IkReal x25=((1.0)*x15);
eetrans[2]=((0.199)+(((0.103)*x3))+((x7*(((((-1.0)*x1*x25))+(((0.143)*x20))))))+((x6*(((((-0.143)*x21))+(((-1.0)*x25*x3))))))+(((-0.098)*x24))+(((0.098)*x20)));
IkReal x26=((1.0)*x12);
eerot[0]=(((x5*x9))+(((-1.0)*x8*((((x10*((((x0*x20))+(((-1.0)*x24*x26))))))+((x18*(((((-1.0)*x19*x26))+(((-1.0)*x21*x26)))))))))));
IkReal x27=((1.0)*x16);
eerot[1]=((((-1.0)*x8*((((x10*(((((-1.0)*x24*x27))+((x20*x5))))))+((x18*(((((-1.0)*x19*x27))+(((-1.0)*x21*x27))))))))))+(((-1.0)*x12*x9)));
eerot[2]=((-1.0)*x8*((((x18*(((((-1.0)*x20))+x24))))+((x10*(((((-1.0)*x21))+(((-1.0)*x19)))))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_r00=r00;
new_px=((-0.085)+px);
new_r01=r01;
new_py=((0.01)+py);
new_r02=r02;
new_pz=((-0.199)+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j0eval[2];
j0eval[0]=((px*px)+(py*py));
j0eval[1]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x30 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x30.valid){
continue;
}
IkReal x28=((1.0)*(x30.value));
if((((px*px)+(py*py))) < -0.00001)
continue;
CheckValue<IkReal> x31=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);
if(!x31.valid){
continue;
}
if( (((0.015)*(x31.value))) < -1-IKFAST_SINCOS_THRESH || (((0.015)*(x31.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x29=IKasin(((0.015)*(x31.value)));
j0array[0]=((((-1.0)*x28))+(((-1.0)*x29)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x28))+x29);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

IkReal op[8+1], zeror[8];
int numroots;
IkReal x32=((100.5)*r02);
IkReal x33=((2.5)*r02);
IkReal x34=((100.5)*pz);
IkReal x35=((2.5)*pz);
IkReal x36=(py*sj0);
IkReal x37=((7.5)*sj0);
IkReal x38=(cj0*r00);
IkReal x39=(r01*sj0);
IkReal x40=(cj0*px);
IkReal x41=((7.5)*cj0);
IkReal x42=(r01*x41);
IkReal x43=(py*x41);
IkReal x44=((5.0)*x38);
IkReal x45=((5.0)*x39);
IkReal x46=((5.0)*x40);
IkReal x47=((5.0)*x36);
IkReal x48=((500.0)*pz*r02);
IkReal x49=((500.0)*py*r01);
IkReal x50=(r00*x37);
IkReal x51=((500.0)*px*r00);
IkReal x52=((250.0)*(py*py));
IkReal x53=(px*x37);
IkReal x54=((250.0)*(pz*pz));
IkReal x55=((250.0)*(px*px));
IkReal x56=((98.0)*x40);
IkReal x57=((98.0)*x36);
IkReal x58=((5.02475)+x43);
IkReal x59=((-5.06925)+x43);
IkReal x60=((((98.0)*x39))+(((98.0)*x38)));
IkReal x61=((((201.0)*x38))+(((201.0)*x39)));
IkReal x62=(x44+x45);
IkReal x63=((-1.0)*x60);
IkReal x64=((-0.98)+(((-1.0)*x56))+(((-1.0)*x57)));
IkReal x65=(x57+x56);
IkReal x66=(x46+x47);
IkReal x67=((0.98)+x65);
IkReal x68=((2.01)+(((201.0)*x40))+(((201.0)*x36)));
IkReal x69=((0.05)+x66);
IkReal x70=(x55+x54+x53+x52);
IkReal x71=(x48+x49+x51+x50+x62);
IkReal x72=(x70+x66);
IkReal x73=((((-1.0)*x71))+x32+x42);
IkReal x74=((((-1.0)*x71))+x33+x42);
IkReal x75=((((-1.0)*x71))+(((-1.0)*x32))+x42);
IkReal x76=((((-1.0)*x71))+(((-1.0)*x33))+x42);
IkReal x77=((((-1.0)*x72))+x34+x59);
IkReal x78=((((-1.0)*x72))+x35+x58);
IkReal x79=((((-1.0)*x72))+(((-1.0)*x34))+x59);
IkReal x80=((((-1.0)*x72))+(((-1.0)*x35))+x58);
IkReal gconst0=x73;
IkReal gconst1=x60;
IkReal gconst2=x74;
IkReal gconst3=x77;
IkReal gconst4=x67;
IkReal gconst5=x78;
IkReal gconst6=x73;
IkReal gconst7=x60;
IkReal gconst8=x74;
IkReal gconst9=x77;
IkReal gconst10=x67;
IkReal gconst11=x78;
IkReal gconst12=x61;
IkReal gconst13=x62;
IkReal gconst14=x68;
IkReal gconst15=x69;
IkReal gconst16=x61;
IkReal gconst17=x62;
IkReal gconst18=x68;
IkReal gconst19=x69;
IkReal gconst20=x75;
IkReal gconst21=x63;
IkReal gconst22=x76;
IkReal gconst23=x79;
IkReal gconst24=x64;
IkReal gconst25=x80;
IkReal gconst26=x75;
IkReal gconst27=x63;
IkReal gconst28=x76;
IkReal gconst29=x79;
IkReal gconst30=x64;
IkReal gconst31=x80;
IkReal x81=(gconst23*gconst31);
IkReal x82=(gconst13*gconst26);
IkReal x83=(gconst22*gconst26);
IkReal x84=((196.0)*pz);
IkReal x85=((1.0)*gconst2);
IkReal x86=(gconst16*gconst22);
IkReal x87=(gconst3*gconst8);
IkReal x88=(gconst18*gconst7);
IkReal x89=(gconst2*gconst4);
IkReal x90=(gconst21*gconst30);
IkReal x91=(gconst15*gconst26);
IkReal x92=((1.0)*gconst5);
IkReal x93=(gconst7*gconst9);
IkReal x94=(gconst28*gconst29);
IkReal x95=((1.0)*gconst22);
IkReal x96=((196.0)*r02);
IkReal x97=(gconst27*gconst29);
IkReal x98=(gconst0*gconst11);
IkReal x99=((1.0)*gconst13);
IkReal x100=(gconst11*gconst2);
IkReal x101=(gconst12*gconst25);
IkReal x102=(gconst11*gconst6);
IkReal x103=(gconst1*gconst5);
IkReal x104=(gconst10*gconst6);
IkReal x105=((1.0)*gconst15);
IkReal x106=(gconst18*gconst25);
IkReal x107=((1.0)*gconst21);
IkReal x108=(gconst17*gconst29);
IkReal x109=(gconst25*gconst26);
IkReal x110=((1.0)*gconst31);
IkReal x111=(gconst17*gconst9);
IkReal x112=(gconst20*gconst25);
IkReal x113=(gconst0*gconst8);
IkReal x114=(gconst22*gconst24);
IkReal x115=(gconst5*gconst9);
IkReal x116=(gconst10*gconst16);
IkReal x117=(gconst4*x104);
IkReal x118=(gconst2*gconst3*gconst6);
IkReal x119=((1.0)*gconst24*gconst30);
IkReal x120=(x110*x112);
op[0]=(((x81*x83))+(((-1.0)*x119*x83))+((x114*x97))+(((-1.0)*gconst25*x107*x97))+(((-1.0)*gconst23*x94*x95))+((x112*x94))+((x109*x90))+(((-1.0)*gconst20*x109*x110)));
op[1]=(((gconst30*x83*x84))+(((-1.0)*gconst19*gconst20*x109))+(((-1.0)*gconst29*x114*x96))+((gconst16*gconst25*x90))+((x81*x86))+((x81*x82))+((gconst21*gconst25*gconst29*x96))+(((-1.0)*x119*x86))+(((-1.0)*x119*x82))+((x101*x94))+((gconst19*gconst23*x83))+(((-1.0)*gconst27*x106*x107))+((gconst20*gconst28*x106))+((gconst24*x83*x84))+(((-1.0)*gconst23*x108*x95))+((gconst14*gconst31*x83))+(((-1.0)*gconst18*gconst23*gconst28*x95))+(((-1.0)*gconst21*x109*x84))+(((-1.0)*gconst26*x101*x110))+((gconst13*gconst24*x97))+(((-1.0)*gconst23*x94*x99))+((x90*x91))+(((-1.0)*gconst22*x84*x97))+((x108*x112))+((gconst18*gconst27*x114))+((gconst15*gconst20*x94))+(((-1.0)*gconst14*x94*x95))+(((-1.0)*gconst21*x105*x97))+(((-1.0)*gconst16*x120))+(((-1.0)*gconst30*x109*x96))+(((-1.0)*gconst20*x110*x91))+((gconst25*x96*x97)));
op[2]=((((-1.0)*gconst21*gconst25*gconst29*gconst7))+((gconst10*gconst21*gconst25*gconst26))+((gconst20*gconst25*gconst29*gconst8))+((gconst2*gconst24*gconst27*gconst29))+(((38416.0)*gconst25*gconst26*pz*r02))+(((-38416.0)*gconst25*gconst29*(r02*r02)))+((gconst17*gconst18*gconst20*gconst25))+(((-38416.0)*gconst22*gconst26*(pz*pz)))+((gconst11*gconst22*gconst23*gconst26))+((gconst12*gconst18*gconst25*gconst28))+(((-1.0)*gconst22*gconst23*gconst28*gconst9))+((gconst13*gconst16*gconst23*gconst31))+((gconst16*gconst19*gconst22*gconst23))+(((-1.0)*gconst17*gconst18*gconst22*gconst23))+((gconst2*gconst23*gconst26*gconst31))+((gconst21*gconst25*gconst30*gconst6))+(((196.0)*gconst13*gconst26*gconst30*pz))+(((-1.0)*gconst2*gconst23*gconst28*gconst29))+((gconst22*gconst24*gconst27*gconst9))+(((-1.0)*gconst22*gconst26*gconst30*gconst4))+(((-196.0)*gconst15*gconst21*gconst26*pz))+((gconst14*gconst19*gconst22*gconst26))+(((-1.0)*gconst1*gconst25*gconst27*gconst29))+(((-196.0)*gconst13*gconst27*gconst29*pz))+(((-1.0)*gconst20*gconst26*gconst31*gconst5))+(((-1.0)*gconst13*gconst16*gconst24*gconst30))+(((-196.0)*gconst16*gconst21*gconst25*pz))+(((196.0)*gconst16*gconst22*gconst24*pz))+(((-1.0)*gconst10*gconst22*gconst24*gconst26))+(((196.0)*gconst18*gconst25*gconst27*r02))+((gconst1*gconst25*gconst26*gconst30))+(((196.0)*gconst16*gconst22*gconst30*pz))+(((-1.0)*gconst20*gconst25*gconst31*gconst6))+((gconst15*gconst18*gconst20*gconst28))+(((-196.0)*gconst15*gconst26*gconst30*r02))+(((-1.0)*gconst14*gconst18*gconst22*gconst28))+((gconst15*gconst16*gconst21*gconst30))+((gconst12*gconst17*gconst25*gconst29))+((gconst20*gconst28*gconst29*gconst5))+((gconst21*gconst26*gconst30*gconst5))+(((-196.0)*gconst18*gconst22*gconst27*pz))+((gconst22*gconst27*gconst29*gconst4))+((gconst22*gconst24*gconst29*gconst7))+((gconst22*gconst26*gconst3*gconst31))+(((-1.0)*gconst22*gconst28*gconst29*gconst3))+(((-1.0)*gconst13*gconst17*gconst23*gconst29))+(((-1.0)*gconst15*gconst19*gconst20*gconst26))+((gconst12*gconst15*gconst28*gconst29))+(((196.0)*gconst18*gconst21*gconst25*r02))+(((-1.0)*gconst12*gconst15*gconst26*gconst31))+(((-1.0)*gconst2*gconst24*gconst26*gconst30))+((gconst13*gconst18*gconst24*gconst27))+(((-1.0)*gconst11*gconst20*gconst25*gconst26))+((gconst22*gconst23*gconst31*gconst6))+(((-196.0)*gconst18*gconst22*gconst24*r02))+(((-1.0)*gconst12*gconst16*gconst25*gconst31))+(((196.0)*gconst15*gconst27*gconst29*r02))+(((-1.0)*gconst16*gconst19*gconst20*gconst25))+(((-1.0)*gconst13*gconst14*gconst28*gconst29))+((gconst14*gconst16*gconst22*gconst31))+((gconst15*gconst17*gconst20*gconst29))+(((-1.0)*gconst15*gconst16*gconst20*gconst31))+(((-1.0)*gconst22*gconst24*gconst30*gconst6))+(((196.0)*gconst15*gconst21*gconst29*r02))+(((-1.0)*gconst0*gconst25*gconst26*gconst31))+((gconst20*gconst25*gconst28*gconst9))+(((-1.0)*gconst14*gconst17*gconst22*gconst29))+(((-196.0)*gconst16*gconst25*gconst30*r02))+(((-1.0)*gconst21*gconst27*gconst29*gconst5))+(((-1.0)*gconst21*gconst25*gconst27*gconst9))+(((38416.0)*gconst22*gconst29*pz*r02))+(((-1.0)*gconst15*gconst18*gconst21*gconst27))+(((-196.0)*gconst13*gconst24*gconst29*r02))+((gconst13*gconst19*gconst23*gconst26))+((gconst13*gconst14*gconst26*gconst31))+(((196.0)*gconst13*gconst24*gconst26*pz))+(((-1.0)*gconst13*gconst18*gconst23*gconst28))+((gconst0*gconst25*gconst28*gconst29))+(((-1.0)*gconst12*gconst19*gconst25*gconst26))+(((-1.0)*gconst22*gconst23*gconst29*gconst8)));
op[3]=((((-1.0)*gconst14*gconst2*gconst28*gconst29))+(((-1.0)*gconst19*gconst20*gconst26*gconst5))+((gconst19*gconst2*gconst23*gconst26))+((gconst15*gconst21*gconst30*gconst6))+(((-1.0)*gconst11*gconst16*gconst20*gconst25))+((gconst16*gconst21*gconst30*gconst5))+(((-1.0)*gconst19*gconst20*gconst25*gconst6))+(((-196.0)*gconst22*gconst24*gconst9*r02))+((gconst0*gconst15*gconst28*gconst29))+(((-196.0)*gconst21*gconst26*gconst5*pz))+(((-1.0)*gconst15*gconst21*gconst27*gconst9))+(((-1.0)*gconst12*gconst26*gconst31*gconst5))+(((-196.0)*gconst26*gconst30*gconst5*r02))+((gconst15*gconst20*gconst29*gconst8))+((gconst14*gconst2*gconst26*gconst31))+(((-1.0)*gconst18*gconst22*gconst23*gconst8))+(((196.0)*gconst21*gconst25*gconst9*r02))+((gconst13*gconst24*gconst27*gconst9))+(((196.0)*gconst25*gconst29*gconst7*r02))+((gconst13*gconst24*gconst29*gconst7))+((gconst18*gconst22*gconst27*gconst4))+(((-38416.0)*gconst15*gconst29*(r02*r02)))+(((-1.0)*gconst11*gconst12*gconst25*gconst26))+((gconst17*gconst20*gconst25*gconst9))+(((196.0)*gconst13*gconst16*gconst30*pz))+(((196.0)*gconst22*gconst30*gconst6*pz))+(((-38416.0)*gconst16*gconst22*(pz*pz)))+((gconst12*gconst25*gconst29*gconst8))+(((-1.0)*gconst18*gconst21*gconst27*gconst5))+((gconst18*gconst22*gconst24*gconst7))+((gconst18*gconst20*gconst25*gconst8))+(((-1.0)*gconst17*gconst2*gconst23*gconst29))+(((-196.0)*gconst15*gconst16*gconst21*pz))+(((-1.0)*gconst13*gconst24*gconst30*gconst6))+((gconst11*gconst16*gconst22*gconst23))+((gconst13*gconst16*gconst19*gconst23))+((gconst12*gconst25*gconst28*gconst9))+(((-196.0)*gconst1*gconst25*gconst26*pz))+(((-1.0)*gconst11*gconst15*gconst20*gconst26))+(((-1.0)*gconst12*gconst25*gconst31*gconst6))+((gconst17*gconst20*gconst29*gconst5))+((gconst15*gconst20*gconst28*gconst9))+(((-1.0)*gconst15*gconst16*gconst19*gconst20))+((gconst13*gconst26*gconst3*gconst31))+(((-1.0)*gconst0*gconst19*gconst25*gconst26))+((gconst18*gconst2*gconst24*gconst27))+((gconst10*gconst15*gconst21*gconst26))+(((196.0)*gconst15*gconst18*gconst27*r02))+(((-196.0)*gconst22*gconst29*gconst7*pz))+(((-1.0)*gconst1*gconst15*gconst27*gconst29))+(((-1.0)*gconst16*gconst22*gconst30*gconst4))+(((-1.0)*gconst18*gconst22*gconst28*gconst3))+(((-1.0)*gconst12*gconst16*gconst19*gconst25))+(((38416.0)*gconst18*gconst22*pz*r02))+(((-1.0)*gconst10*gconst16*gconst22*gconst24))+((gconst11*gconst13*gconst23*gconst26))+(((196.0)*gconst1*gconst25*gconst29*r02))+(((196.0)*gconst27*gconst29*gconst5*r02))+(((-1.0)*gconst18*gconst2*gconst23*gconst28))+(((-196.0)*gconst10*gconst25*gconst26*r02))+(((-196.0)*gconst2*gconst27*gconst29*pz))+(((-1.0)*gconst13*gconst14*gconst18*gconst28))+(((196.0)*gconst22*gconst24*gconst6*pz))+(((-38416.0)*gconst13*gconst26*(pz*pz)))+(((-196.0)*gconst22*gconst29*gconst4*r02))+(((196.0)*gconst21*gconst29*gconst5*r02))+((gconst1*gconst15*gconst26*gconst30))+(((-1.0)*gconst12*gconst15*gconst19*gconst26))+(((-1.0)*gconst17*gconst22*gconst23*gconst9))+(((38416.0)*gconst16*gconst25*pz*r02))+(((-38416.0)*gconst18*gconst25*(r02*r02)))+(((-1.0)*gconst15*gconst20*gconst31*gconst6))+(((-1.0)*gconst1*gconst18*gconst25*gconst27))+(((-196.0)*gconst25*gconst30*gconst6*r02))+(((-1.0)*gconst13*gconst17*gconst18*gconst23))+(((196.0)*gconst22*gconst26*gconst4*pz))+(((-1.0)*gconst15*gconst21*gconst29*gconst7))+(((-1.0)*gconst14*gconst17*gconst18*gconst22))+((gconst1*gconst16*gconst25*gconst30))+(((-1.0)*gconst18*gconst21*gconst25*gconst7))+((gconst12*gconst15*gconst18*gconst28))+(((-1.0)*gconst13*gconst23*gconst28*gconst9))+((gconst13*gconst23*gconst31*gconst6))+(((-196.0)*gconst21*gconst25*gconst6*pz))+(((-1.0)*gconst13*gconst23*gconst29*gconst8))+(((-1.0)*gconst17*gconst22*gconst29*gconst3))+((gconst13*gconst27*gconst29*gconst4))+((gconst16*gconst22*gconst3*gconst31))+(((-196.0)*gconst13*gconst18*gconst27*pz))+(((-1.0)*gconst16*gconst20*gconst31*gconst5))+(((-1.0)*gconst13*gconst14*gconst17*gconst29))+(((196.0)*gconst13*gconst16*gconst24*pz))+((gconst19*gconst22*gconst23*gconst6))+(((-1.0)*gconst12*gconst15*gconst16*gconst31))+(((196.0)*gconst15*gconst18*gconst21*r02))+(((-1.0)*gconst13*gconst26*gconst30*gconst4))+((gconst0*gconst17*gconst25*gconst29))+((gconst16*gconst2*gconst23*gconst31))+(((196.0)*gconst2*gconst26*gconst30*pz))+((gconst12*gconst28*gconst29*gconst5))+(((-196.0)*gconst15*gconst16*gconst30*r02))+((gconst15*gconst17*gconst18*gconst20))+(((-1.0)*gconst0*gconst16*gconst25*gconst31))+(((-196.0)*gconst22*gconst27*gconst9*pz))+((gconst13*gconst14*gconst16*gconst31))+(((-196.0)*gconst13*gconst18*gconst24*r02))+(((-1.0)*gconst10*gconst13*gconst24*gconst26))+((gconst13*gconst14*gconst19*gconst26))+((gconst18*gconst20*gconst28*gconst5))+(((196.0)*gconst10*gconst22*gconst26*pz))+((gconst11*gconst14*gconst22*gconst26))+(((38416.0)*gconst15*gconst26*pz*r02))+(((196.0)*gconst2*gconst24*gconst26*pz))+((gconst12*gconst17*gconst18*gconst25))+(((-1.0)*gconst13*gconst28*gconst29*gconst3))+((gconst10*gconst16*gconst21*gconst25))+(((-1.0)*gconst14*gconst22*gconst28*gconst9))+((gconst12*gconst15*gconst17*gconst29))+(((196.0)*gconst25*gconst27*gconst9*r02))+(((-1.0)*gconst16*gconst2*gconst24*gconst30))+((gconst14*gconst22*gconst31*gconst6))+((gconst19*gconst22*gconst26*gconst3))+(((38416.0)*gconst13*gconst29*pz*r02))+(((-1.0)*gconst14*gconst22*gconst29*gconst8))+((gconst0*gconst18*gconst25*gconst28))+((gconst14*gconst16*gconst19*gconst22))+(((-1.0)*gconst0*gconst15*gconst26*gconst31))+(((-196.0)*gconst2*gconst24*gconst29*r02)));
op[4]=((((-196.0)*gconst10*gconst16*gconst25*r02))+((gconst0*gconst25*gconst28*gconst9))+((gconst11*gconst13*gconst16*gconst23))+(((-1.0)*gconst10*gconst13*gconst16*gconst24))+((gconst11*gconst22*gconst26*gconst3))+((gconst1*gconst10*gconst25*gconst26))+(((196.0)*gconst18*gconst21*gconst5*r02))+(((-1.0)*gconst1*gconst15*gconst18*gconst27))+(((-196.0)*gconst18*gconst2*gconst24*r02))+((gconst16*gconst19*gconst2*gconst23))+((gconst2*gconst27*gconst29*gconst4))+(((-38416.0)*gconst15*gconst18*(r02*r02)))+(((-1.0)*gconst14*gconst18*gconst2*gconst28))+((gconst11*gconst22*gconst23*gconst6))+(((-1.0)*gconst2*gconst28*gconst29*gconst3))+(((-38416.0)*gconst25*gconst9*(r02*r02)))+(((-1.0)*gconst16*gconst19*gconst20*gconst5))+(((196.0)*gconst1*gconst15*gconst29*r02))+(((-1.0)*gconst13*gconst16*gconst30*gconst4))+((gconst1*gconst25*gconst30*gconst6))+((gconst0*gconst28*gconst29*gconst5))+(((-1.0)*gconst13*gconst18*gconst28*gconst3))+((gconst20*gconst28*gconst5*gconst9))+(((-196.0)*gconst16*gconst30*gconst5*r02))+(((-1.0)*gconst12*gconst19*gconst26*gconst5))+((gconst21*gconst30*gconst5*gconst6))+(((196.0)*gconst13*gconst30*gconst6*pz))+(((-1.0)*gconst0*gconst11*gconst25*gconst26))+((gconst14*gconst19*gconst22*gconst6))+((gconst13*gconst19*gconst26*gconst3))+((gconst0*gconst15*gconst18*gconst28))+(((38416.0)*gconst25*gconst6*pz*r02))+(((-1.0)*gconst11*gconst20*gconst25*gconst6))+((gconst0*gconst25*gconst29*gconst8))+(((-1.0)*gconst2*gconst26*gconst30*gconst4))+(((-1.0)*gconst10*gconst22*gconst24*gconst6))+(((-1.0)*gconst14*gconst17*gconst22*gconst9))+((gconst17*gconst18*gconst20*gconst5))+((gconst1*gconst26*gconst30*gconst5))+(((-1.0)*gconst15*gconst18*gconst21*gconst7))+(((-1.0)*gconst17*gconst18*gconst2*gconst23))+(((-1.0)*gconst15*gconst19*gconst20*gconst6))+(((-1.0)*gconst12*gconst19*gconst25*gconst6))+(((196.0)*gconst18*gconst25*gconst7*r02))+(((-1.0)*gconst2*gconst24*gconst30*gconst6))+((gconst15*gconst18*gconst20*gconst8))+(((-196.0)*gconst18*gconst22*gconst4*r02))+((gconst13*gconst18*gconst27*gconst4))+((gconst22*gconst24*gconst7*gconst9))+((gconst22*gconst27*gconst4*gconst9))+(((-1.0)*gconst0*gconst25*gconst31*gconst6))+((gconst1*gconst15*gconst16*gconst30))+((gconst2*gconst23*gconst31*gconst6))+(((-1.0)*gconst21*gconst29*gconst5*gconst7))+(((-1.0)*gconst1*gconst27*gconst29*gconst5))+((gconst14*gconst16*gconst2*gconst31))+(((-1.0)*gconst20*gconst31*gconst5*gconst6))+(((196.0)*gconst13*gconst26*gconst4*pz))+((gconst22*gconst29*gconst4*gconst7))+((gconst20*gconst25*gconst8*gconst9))+(((38416.0)*gconst22*gconst9*pz*r02))+(((196.0)*gconst10*gconst16*gconst22*pz))+(((-196.0)*gconst1*gconst16*gconst25*pz))+(((196.0)*gconst1*gconst18*gconst25*r02))+(((196.0)*gconst15*gconst21*gconst9*r02))+((gconst15*gconst17*gconst20*gconst9))+(((-1.0)*gconst1*gconst25*gconst27*gconst9))+(((-1.0)*gconst0*gconst15*gconst19*gconst26))+(((-196.0)*gconst15*gconst21*gconst6*pz))+((gconst2*gconst24*gconst29*gconst7))+(((-1.0)*gconst14*gconst18*gconst22*gconst8))+(((38416.0)*gconst26*gconst5*pz*r02))+(((196.0)*gconst18*gconst27*gconst5*r02))+(((-196.0)*gconst15*gconst30*gconst6*r02))+((gconst14*gconst19*gconst2*gconst26))+(((-1.0)*gconst0*gconst16*gconst19*gconst25))+(((-196.0)*gconst10*gconst15*gconst26*r02))+(((-1.0)*gconst22*gconst23*gconst8*gconst9))+(((-1.0)*gconst13*gconst14*gconst29*gconst8))+(((-1.0)*gconst0*gconst26*gconst31*gconst5))+((gconst13*gconst16*gconst3*gconst31))+(((-1.0)*gconst11*gconst12*gconst15*gconst26))+(((-1.0)*gconst17*gconst18*gconst22*gconst3))+(((-1.0)*gconst21*gconst25*gconst7*gconst9))+(((38416.0)*gconst15*gconst16*pz*r02))+(((-196.0)*gconst13*gconst27*gconst9*pz))+(((-1.0)*gconst10*gconst22*gconst26*gconst4))+((gconst0*gconst17*gconst18*gconst25))+(((-1.0)*gconst13*gconst18*gconst23*gconst8))+((gconst11*gconst14*gconst16*gconst22))+(((38416.0)*gconst2*gconst29*pz*r02))+(((-1.0)*gconst22*gconst28*gconst3*gconst9))+((gconst16*gconst19*gconst22*gconst3))+(((-1.0)*gconst14*gconst17*gconst2*gconst29))+(((-1.0)*gconst13*gconst14*gconst28*gconst9))+(((-1.0)*gconst12*gconst15*gconst31*gconst6))+(((-1.0)*gconst12*gconst15*gconst16*gconst19))+(((-196.0)*gconst13*gconst29*gconst4*r02))+(((-1.0)*gconst11*gconst15*gconst16*gconst20))+(((196.0)*gconst13*gconst24*gconst6*pz))+(((-1.0)*gconst11*gconst12*gconst16*gconst25))+(((196.0)*gconst10*gconst13*gconst26*pz))+((gconst20*gconst29*gconst5*gconst8))+(((-1.0)*gconst13*gconst17*gconst23*gconst9))+((gconst2*gconst26*gconst3*gconst31))+(((-1.0)*gconst13*gconst14*gconst17*gconst18))+(((-1.0)*gconst22*gconst29*gconst3*gconst8))+(((-38416.0)*gconst29*gconst5*(r02*r02)))+(((196.0)*gconst15*gconst29*gconst7*r02))+(((196.0)*gconst16*gconst22*gconst4*pz))+((gconst11*gconst2*gconst23*gconst26))+((gconst10*gconst21*gconst25*gconst6))+(((-196.0)*gconst1*gconst15*gconst26*pz))+(((-38416.0)*gconst13*gconst16*(pz*pz)))+((gconst10*gconst15*gconst16*gconst21))+(((196.0)*gconst15*gconst27*gconst9*r02))+((gconst10*gconst21*gconst26*gconst5))+(((-196.0)*gconst16*gconst21*gconst5*pz))+((gconst13*gconst19*gconst23*gconst6))+(((-1.0)*gconst2*gconst23*gconst29*gconst8))+((gconst2*gconst24*gconst27*gconst9))+((gconst13*gconst14*gconst31*gconst6))+(((-196.0)*gconst18*gconst2*gconst27*pz))+((gconst12*gconst18*gconst25*gconst8))+(((-1.0)*gconst0*gconst15*gconst16*gconst31))+(((-1.0)*gconst21*gconst27*gconst5*gconst9))+((gconst0*gconst15*gconst17*gconst29))+((gconst11*gconst13*gconst14*gconst26))+(((-1.0)*gconst10*gconst2*gconst24*gconst26))+((gconst12*gconst15*gconst17*gconst18))+((gconst12*gconst18*gconst28*gconst5))+((gconst12*gconst17*gconst29*gconst5))+(((-1.0)*gconst2*gconst23*gconst28*gconst9))+(((-38416.0)*gconst2*gconst26*(pz*pz)))+((gconst12*gconst15*gconst29*gconst8))+(((-38416.0)*gconst22*gconst6*(pz*pz)))+(((-196.0)*gconst18*gconst22*gconst7*pz))+(((-1.0)*gconst22*gconst30*gconst4*gconst6))+(((196.0)*gconst16*gconst2*gconst24*pz))+((gconst12*gconst15*gconst28*gconst9))+((gconst12*gconst17*gconst25*gconst9))+(((196.0)*gconst16*gconst2*gconst30*pz))+(((-1.0)*gconst11*gconst20*gconst26*gconst5))+(((-1.0)*gconst12*gconst16*gconst31*gconst5))+(((-1.0)*gconst13*gconst17*gconst29*gconst3))+(((38416.0)*gconst13*gconst18*pz*r02))+((gconst22*gconst3*gconst31*gconst6))+(((-196.0)*gconst13*gconst24*gconst9*r02))+(((-1.0)*gconst1*gconst25*gconst29*gconst7))+((gconst13*gconst18*gconst24*gconst7))+((gconst13*gconst14*gconst16*gconst19))+(((-196.0)*gconst13*gconst29*gconst7*pz)));
op[5]=((((-38416.0)*gconst18*gconst5*(r02*r02)))+(((-1.0)*gconst13*gconst30*gconst4*gconst6))+((gconst12*gconst25*gconst8*gconst9))+(((-1.0)*gconst13*gconst17*gconst18*gconst3))+(((-196.0)*gconst21*gconst5*gconst6*pz))+(((196.0)*gconst10*gconst2*gconst26*pz))+((gconst13*gconst29*gconst4*gconst7))+(((-1.0)*gconst17*gconst2*gconst23*gconst9))+(((38416.0)*gconst16*gconst5*pz*r02))+(((-196.0)*gconst1*gconst25*gconst6*pz))+((gconst1*gconst15*gconst30*gconst6))+((gconst11*gconst14*gconst22*gconst6))+(((-1.0)*gconst10*gconst16*gconst2*gconst24))+(((196.0)*gconst15*gconst18*gconst7*r02))+((gconst11*gconst13*gconst23*gconst6))+(((196.0)*gconst22*gconst4*gconst6*pz))+(((-1.0)*gconst13*gconst14*gconst17*gconst9))+(((-1.0)*gconst1*gconst18*gconst25*gconst7))+(((-1.0)*gconst10*gconst13*gconst26*gconst4))+(((-196.0)*gconst22*gconst4*gconst9*r02))+((gconst18*gconst2*gconst24*gconst7))+((gconst14*gconst2*gconst31*gconst6))+((gconst19*gconst22*gconst3*gconst6))+(((-196.0)*gconst10*gconst25*gconst6*r02))+(((-1.0)*gconst12*gconst31*gconst5*gconst6))+((gconst12*gconst17*gconst18*gconst5))+(((196.0)*gconst29*gconst5*gconst7*r02))+(((-1.0)*gconst13*gconst28*gconst3*gconst9))+(((-1.0)*gconst12*gconst16*gconst19*gconst5))+(((-1.0)*gconst0*gconst19*gconst25*gconst6))+(((-196.0)*gconst1*gconst26*gconst5*pz))+((gconst16*gconst2*gconst3*gconst31))+((gconst1*gconst16*gconst30*gconst5))+(((-196.0)*gconst2*gconst29*gconst7*pz))+(((-196.0)*gconst22*gconst7*gconst9*pz))+((gconst13*gconst14*gconst19*gconst6))+((gconst10*gconst15*gconst21*gconst6))+(((-1.0)*gconst0*gconst19*gconst26*gconst5))+((gconst11*gconst16*gconst2*gconst23))+(((38416.0)*gconst15*gconst6*pz*r02))+(((-196.0)*gconst10*gconst26*gconst5*r02))+((gconst11*gconst14*gconst2*gconst26))+(((-1.0)*gconst13*gconst14*gconst18*gconst8))+(((196.0)*gconst2*gconst30*gconst6*pz))+((gconst0*gconst18*gconst25*gconst8))+((gconst10*gconst16*gconst21*gconst5))+((gconst0*gconst17*gconst29*gconst5))+((gconst1*gconst10*gconst16*gconst25))+(((-1.0)*gconst17*gconst22*gconst3*gconst9))+((gconst19*gconst2*gconst23*gconst6))+((gconst17*gconst20*gconst5*gconst9))+(((196.0)*gconst1*gconst29*gconst5*r02))+(((196.0)*gconst1*gconst25*gconst9*r02))+((gconst0*gconst18*gconst28*gconst5))+((gconst18*gconst2*gconst27*gconst4))+(((-1.0)*gconst13*gconst29*gconst3*gconst8))+(((-196.0)*gconst10*gconst15*gconst16*r02))+(((196.0)*gconst10*gconst22*gconst6*pz))+(((-1.0)*gconst11*gconst15*gconst20*gconst6))+(((196.0)*gconst13*gconst16*gconst4*pz))+((gconst13*gconst24*gconst7*gconst9))+((gconst13*gconst16*gconst19*gconst3))+(((-1.0)*gconst13*gconst23*gconst8*gconst9))+(((-1.0)*gconst18*gconst2*gconst23*gconst8))+((gconst12*gconst15*gconst18*gconst8))+(((-1.0)*gconst0*gconst11*gconst16*gconst25))+(((-196.0)*gconst1*gconst15*gconst16*pz))+((gconst12*gconst29*gconst5*gconst8))+((gconst18*gconst20*gconst5*gconst8))+(((-1.0)*gconst18*gconst21*gconst5*gconst7))+(((-1.0)*gconst14*gconst2*gconst29*gconst8))+(((196.0)*gconst10*gconst13*gconst16*pz))+(((-196.0)*gconst2*gconst27*gconst9*pz))+(((-1.0)*gconst11*gconst16*gconst20*gconst5))+(((-1.0)*gconst11*gconst12*gconst15*gconst16))+((gconst13*gconst3*gconst31*gconst6))+(((196.0)*gconst25*gconst7*gconst9*r02))+((gconst11*gconst13*gconst26*gconst3))+(((-1.0)*gconst11*gconst12*gconst26*gconst5))+(((-1.0)*gconst18*gconst2*gconst28*gconst3))+(((-196.0)*gconst13*gconst18*gconst7*pz))+(((-1.0)*gconst1*gconst18*gconst27*gconst5))+(((-1.0)*gconst1*gconst15*gconst27*gconst9))+(((-1.0)*gconst14*gconst2*gconst28*gconst9))+(((-1.0)*gconst14*gconst17*gconst18*gconst2))+(((-196.0)*gconst2*gconst29*gconst4*r02))+(((-1.0)*gconst11*gconst12*gconst25*gconst6))+(((196.0)*gconst27*gconst5*gconst9*r02))+(((-1.0)*gconst0*gconst15*gconst16*gconst19))+(((196.0)*gconst1*gconst15*gconst18*r02))+(((-38416.0)*gconst16*gconst2*(pz*pz)))+((gconst12*gconst15*gconst17*gconst9))+((gconst15*gconst20*gconst8*gconst9))+(((-38416.0)*gconst13*gconst6*(pz*pz)))+(((-1.0)*gconst18*gconst22*gconst3*gconst8))+((gconst12*gconst28*gconst5*gconst9))+((gconst11*gconst16*gconst22*gconst3))+(((38416.0)*gconst18*gconst2*pz*r02))+(((-38416.0)*gconst15*gconst9*(r02*r02)))+(((-1.0)*gconst10*gconst13*gconst24*gconst6))+(((-1.0)*gconst17*gconst2*gconst29*gconst3))+(((-196.0)*gconst30*gconst5*gconst6*r02))+(((196.0)*gconst21*gconst5*gconst9*r02))+(((196.0)*gconst2*gconst26*gconst4*pz))+(((-1.0)*gconst0*gconst11*gconst15*gconst26))+(((38416.0)*gconst13*gconst9*pz*r02))+((gconst13*gconst27*gconst4*gconst9))+((gconst19*gconst2*gconst26*gconst3))+(((-1.0)*gconst19*gconst20*gconst5*gconst6))+(((-196.0)*gconst13*gconst18*gconst4*r02))+(((-1.0)*gconst1*gconst15*gconst29*gconst7))+(((-1.0)*gconst10*gconst16*gconst22*gconst4))+(((-1.0)*gconst14*gconst22*gconst8*gconst9))+((gconst11*gconst13*gconst14*gconst16))+(((-1.0)*gconst15*gconst21*gconst7*gconst9))+((gconst18*gconst22*gconst4*gconst7))+(((-1.0)*gconst16*gconst2*gconst30*gconst4))+((gconst0*gconst15*gconst28*gconst9))+((gconst14*gconst16*gconst19*gconst2))+((gconst0*gconst15*gconst17*gconst18))+((gconst0*gconst15*gconst29*gconst8))+((gconst1*gconst10*gconst15*gconst26))+(((-1.0)*gconst0*gconst16*gconst31*gconst5))+((gconst0*gconst17*gconst25*gconst9))+(((-196.0)*gconst2*gconst24*gconst9*r02))+(((196.0)*gconst2*gconst24*gconst6*pz))+(((-1.0)*gconst12*gconst15*gconst19*gconst6))+(((-1.0)*gconst0*gconst15*gconst31*gconst6)));
op[6]=((((196.0)*gconst13*gconst4*gconst6*pz))+(((-1.0)*gconst2*gconst29*gconst3*gconst8))+((gconst1*gconst10*gconst26*gconst5))+(((196.0)*gconst15*gconst7*gconst9*r02))+((gconst11*gconst2*gconst23*gconst6))+((gconst1*gconst10*gconst25*gconst6))+((gconst12*gconst15*gconst8*gconst9))+(((-196.0)*gconst13*gconst4*gconst9*r02))+(((196.0)*gconst18*gconst5*gconst7*r02))+(((38416.0)*gconst2*gconst9*pz*r02))+((gconst0*gconst15*gconst18*gconst8))+((gconst0*gconst17*gconst18*gconst5))+(((-1.0)*gconst2*gconst30*gconst4*gconst6))+(((-1.0)*gconst17*gconst18*gconst2*gconst3))+(((-1.0)*gconst14*gconst17*gconst2*gconst9))+((gconst12*gconst18*gconst5*gconst8))+(((-38416.0)*gconst5*gconst9*(r02*r02)))+(((-1.0)*gconst1*gconst27*gconst5*gconst9))+(((-1.0)*gconst0*gconst11*gconst26*gconst5))+((gconst11*gconst14*gconst16*gconst2))+(((-196.0)*gconst18*gconst2*gconst7*pz))+((gconst2*gconst3*gconst31*gconst6))+(((196.0)*gconst1*gconst18*gconst5*r02))+((gconst13*gconst18*gconst4*gconst7))+(((-196.0)*gconst10*gconst15*gconst6*r02))+(((-1.0)*gconst10*gconst2*gconst26*gconst4))+((gconst13*gconst19*gconst3*gconst6))+(((-196.0)*gconst18*gconst2*gconst4*r02))+(((-1.0)*gconst11*gconst12*gconst15*gconst6))+(((38416.0)*gconst5*gconst6*pz*r02))+((gconst2*gconst24*gconst7*gconst9))+((gconst10*gconst21*gconst5*gconst6))+(((-1.0)*gconst13*gconst18*gconst3*gconst8))+(((-1.0)*gconst12*gconst19*gconst5*gconst6))+(((-38416.0)*gconst2*gconst6*(pz*pz)))+((gconst11*gconst13*gconst14*gconst6))+(((-1.0)*gconst11*gconst20*gconst5*gconst6))+(((-196.0)*gconst10*gconst16*gconst5*r02))+(((-1.0)*gconst2*gconst23*gconst8*gconst9))+((gconst11*gconst2*gconst26*gconst3))+((gconst16*gconst19*gconst2*gconst3))+((gconst0*gconst25*gconst8*gconst9))+(((-1.0)*gconst2*gconst28*gconst3*gconst9))+(((-1.0)*gconst0*gconst11*gconst25*gconst6))+(((-1.0)*gconst0*gconst16*gconst19*gconst5))+(((-1.0)*gconst14*gconst18*gconst2*gconst8))+(((-1.0)*gconst22*gconst3*gconst8*gconst9))+((gconst11*gconst22*gconst3*gconst6))+((gconst12*gconst17*gconst5*gconst9))+((gconst0*gconst15*gconst17*gconst9))+(((-1.0)*gconst0*gconst15*gconst19*gconst6))+(((-1.0)*gconst10*gconst13*gconst16*gconst4))+((gconst22*gconst4*gconst7*gconst9))+(((-1.0)*gconst1*gconst29*gconst5*gconst7))+((gconst11*gconst13*gconst16*gconst3))+(((-1.0)*gconst13*gconst14*gconst8*gconst9))+(((-1.0)*gconst10*gconst22*gconst4*gconst6))+(((-1.0)*gconst10*gconst2*gconst24*gconst6))+(((-196.0)*gconst1*gconst15*gconst6*pz))+(((-1.0)*gconst0*gconst11*gconst15*gconst16))+(((-1.0)*gconst1*gconst25*gconst7*gconst9))+(((-1.0)*gconst0*gconst31*gconst5*gconst6))+(((-1.0)*gconst21*gconst5*gconst7*gconst9))+((gconst14*gconst19*gconst2*gconst6))+((gconst0*gconst29*gconst5*gconst8))+((gconst1*gconst10*gconst15*gconst16))+(((196.0)*gconst10*gconst16*gconst2*pz))+(((196.0)*gconst16*gconst2*gconst4*pz))+(((196.0)*gconst10*gconst13*gconst6*pz))+(((196.0)*gconst1*gconst15*gconst9*r02))+(((-196.0)*gconst1*gconst16*gconst5*pz))+(((-1.0)*gconst11*gconst12*gconst16*gconst5))+((gconst2*gconst29*gconst4*gconst7))+((gconst0*gconst28*gconst5*gconst9))+(((-1.0)*gconst1*gconst15*gconst18*gconst7))+(((-1.0)*gconst13*gconst17*gconst3*gconst9))+((gconst20*gconst5*gconst8*gconst9))+((gconst2*gconst27*gconst4*gconst9))+((gconst1*gconst30*gconst5*gconst6))+(((-196.0)*gconst13*gconst7*gconst9*pz)));
op[7]=((((-1.0)*gconst14*gconst8*gconst9*x85))+(((-1.0)*gconst18*x85*x87))+((gconst18*gconst5*x113))+((gconst19*x118))+(((-1.0)*gconst16*x92*x98))+(((-1.0)*gconst1*x88*x92))+(((-1.0)*gconst2*x84*x93))+((gconst5*x93*x96))+((gconst12*gconst8*x115))+((x103*x116))+(((-1.0)*gconst6*x105*x98))+(((-1.0)*gconst12*x102*x92))+(((-1.0)*gconst6*x103*x84))+((gconst14*gconst6*x100))+((gconst6*x84*x89))+((gconst9*x103*x96))+(((-1.0)*gconst1*x105*x93))+((x88*x89))+(((-1.0)*x117*x99))+((gconst1*gconst15*x104))+(((-1.0)*gconst3*x111*x85))+((gconst15*gconst9*x113))+((gconst2*x104*x84))+(((-1.0)*gconst9*x89*x96))+(((-1.0)*gconst0*gconst19*gconst6*x92))+((gconst16*gconst3*x100))+(((-1.0)*gconst9*x87*x99))+(((-1.0)*gconst5*x104*x96))+((gconst13*gconst3*x102))+((gconst13*gconst4*x93))+(((-1.0)*gconst4*x116*x85))+((gconst0*gconst5*x111)));
op[8]=((((-1.0)*gconst9*x85*x87))+((x89*x93))+((x113*x115))+((x103*x104))+(((-1.0)*gconst1*x92*x93))+((gconst3*gconst6*x100))+(((-1.0)*x117*x85))+(((-1.0)*gconst6*x92*x98)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
sj4array[0]=(((r00*sj0))+(((-1.0)*cj0*r01)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
j3eval[0]=cj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x121=(cj0*px);
IkReal x122=((7.34979306407878)*sj1);
IkReal x123=(py*sj0);
cj3array[0]=((-0.682139289282146)+(((-7.34979306407878)*cj1*pz))+(((0.713572142143571)*x123))+(((0.713572142143571)*x121))+(((-1.0)*x121*x122))+(((35.6786071071785)*(px*px)))+(((1.07035821321536)*px*sj0))+(((35.6786071071785)*(pz*pz)))+(((35.6786071071785)*(py*py)))+(((-0.0734979306407878)*sj1))+(((-1.07035821321536)*cj0*py))+(((-1.0)*x122*x123)));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x124=py*py;
IkReal x125=pz*pz;
IkReal x126=px*px;
IkReal x127=(px*r01);
IkReal x128=((2.0)*py);
IkReal x129=(cj0*r01);
IkReal x130=(cj1*r02);
IkReal x131=((0.206)*py);
IkReal x132=(r00*sj0);
IkReal x133=((0.00206)*sj1);
IkReal x134=(pz*r02);
IkReal x135=(cj0*r00);
IkReal x136=((0.00309)*sj1);
IkReal x137=(r01*sj0);
IkReal x138=(px*sj0);
IkReal x139=((0.206)*cj1*pz);
IkReal x140=((1.0)*x126);
evalcond[0]=((-0.030053)+(((0.02)*py*r00))+(((-0.03)*x134))+(((-0.028028)*(IKcos(j3))))+((cj0*x128*x134))+(((-1.0)*cj0*x130*x131))+((px*x128*x135))+(((0.00309)*x130))+((x129*x133))+((x129*x139))+(((-1.0)*x125*x129))+(((-1.0)*x132*x140))+((x135*x136))+(((-0.0003)*x137))+(((-0.0003)*x135))+(((-1.0)*x129*x140))+(((-0.010484)*x129))+((x136*x137))+(((0.206)*sj1*x127))+(((-1.0)*r00*sj1*x131))+(((0.206)*x130*x138))+((x124*x132))+(((0.010484)*x132))+((x125*x132))+(((-1.0)*x132*x139))+(((-1.0)*x132*x133))+((x124*x129))+(((-0.03)*px*r00))+(((-2.0)*x134*x138))+(((-0.03)*py*r01))+(((-1.0)*sj0*x127*x128))+(((-0.02)*x127)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j2eval[0]=((-1.07224917939204)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-30053.0)+(((-28028.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x141=(cj0*px);
IkReal x142=((98000.0)*sj1);
IkReal x143=(py*sj0);
IkReal x144=((98000.0)*cj1);
IkReal x145=((143000.0)*sj3);
IkReal x146=((1430.0)*cj1);
IkReal x147=((1430.0)*sj1);
IkReal x148=((143000.0)*cj1*cj3);
IkReal x149=((143000.0)*cj3*sj1);
CheckValue<IkReal> x150 = IKatan2WithCheck(IkReal((((pz*x142))+((pz*x149))+((sj1*x141*x145))+(((-1.0)*x143*x144))+(((-1.0)*x143*x148))+((cj1*pz*x145))+((sj1*x143*x145))+(((-1.0)*cj3*x146))+(((-1.0)*x141*x144))+(((-1.0)*x141*x148))+(((-980.0)*cj1))+(((-14729.0)*sj3))+((sj3*x147)))),IkReal(((10094.0)+(((-1.0)*x143*x149))+(((14729.0)*cj3))+(((-1.0)*x142*x143))+(((-1.0)*pz*x144))+(((-1.0)*pz*x148))+(((-980.0)*sj1))+(((-1.0)*cj3*x147))+((pz*sj1*x145))+(((-1.0)*x141*x142))+(((-1.0)*x141*x149))+(((-1.0)*sj3*x146))+(((-1.0)*cj1*x143*x145))+(((-1.0)*cj1*x141*x145)))),IKFAST_ATAN2_MAGTHRESH);
if(!x150.valid){
continue;
}
CheckValue<IkReal> x151=IKPowWithIntegerCheck(IKsign(((-30053.0)+(((-28028.0)*cj3)))),-1);
if(!x151.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x150.value)+(((1.5707963267949)*(x151.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x152=IKcos(j2);
IkReal x153=IKsin(j2);
IkReal x154=(px*sj1);
IkReal x155=(r00*sj0);
IkReal x156=(py*sj1);
IkReal x157=(cj1*r02);
IkReal x158=((1.0)*px);
IkReal x159=((0.143)*cj3);
IkReal x160=((0.01)*cj1);
IkReal x161=(cj0*r01);
IkReal x162=(cj1*pz);
IkReal x163=((0.01)*sj1);
IkReal x164=((0.015)*cj1);
IkReal x165=(cj0*r00);
IkReal x166=(pz*sj1);
IkReal x167=(r01*sj0);
IkReal x168=((0.015)*sj1);
IkReal x169=(cj1*py);
IkReal x170=((0.143)*sj3);
IkReal x171=((0.098)*x153);
IkReal x172=((0.098)*x152);
IkReal x173=(x153*x159);
IkReal x174=(x152*x170);
IkReal x175=(x153*x170);
IkReal x176=(x152*x159);
IkReal x177=(x172+x176);
IkReal x178=(x171+x173+x174);
evalcond[0]=((-0.103)+((cj0*x154))+(((-1.0)*x177))+((sj0*x156))+x175+x162+x163);
evalcond[1]=((((-1.0)*x160))+(((-1.0)*sj0*x169))+x178+x166+(((-1.0)*cj0*cj1*x158)));
evalcond[2]=(((x161*x166))+(((-1.0)*cj1*r01*x158))+(((-1.0)*x155*x166))+((r00*x169))+(((-1.0)*x178))+(((-1.0)*x160*x161))+(((-1.0)*cj0*r02*x156))+((r02*sj0*x154))+((x155*x160))+((r02*x168))+(((-1.0)*x164*x165))+(((-1.0)*x164*x167)));
evalcond[3]=((((-1.0)*sj0*x157*x158))+(((-0.015)*x157))+((cj0*py*x157))+(((-0.103)*x155))+(((-1.0)*x177))+(((-1.0)*r01*x154))+((r00*x156))+(((-1.0)*x161*x163))+x175+(((-1.0)*x161*x162))+((x155*x162))+((x155*x163))+(((0.103)*x161))+(((-1.0)*x165*x168))+(((-1.0)*x167*x168)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x179=(cj0*px);
IkReal x180=((7.34979306407878)*sj1);
IkReal x181=(py*sj0);
cj3array[0]=((-0.682139289282146)+(((-7.34979306407878)*cj1*pz))+(((-1.0)*x180*x181))+(((35.6786071071785)*(px*px)))+(((1.07035821321536)*px*sj0))+(((-1.0)*x179*x180))+(((35.6786071071785)*(pz*pz)))+(((35.6786071071785)*(py*py)))+(((-0.0734979306407878)*sj1))+(((-1.07035821321536)*cj0*py))+(((0.713572142143571)*x179))+(((0.713572142143571)*x181)));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x182=py*py;
IkReal x183=pz*pz;
IkReal x184=px*px;
IkReal x185=(px*r01);
IkReal x186=((2.0)*py);
IkReal x187=(cj0*r01);
IkReal x188=(cj1*r02);
IkReal x189=((0.206)*py);
IkReal x190=(r00*sj0);
IkReal x191=((0.00206)*sj1);
IkReal x192=(pz*r02);
IkReal x193=(cj0*r00);
IkReal x194=((0.00309)*sj1);
IkReal x195=(r01*sj0);
IkReal x196=(px*sj0);
IkReal x197=((0.206)*cj1*pz);
IkReal x198=((1.0)*x184);
evalcond[0]=((0.030053)+(((-0.010484)*x187))+(((0.02)*py*r00))+(((0.00309)*x188))+((x193*x194))+((x187*x191))+((x187*x197))+(((-1.0)*x190*x198))+(((-1.0)*x190*x191))+(((-1.0)*x190*x197))+(((-0.02)*x185))+(((0.010484)*x190))+(((-0.0003)*x193))+(((-0.0003)*x195))+((cj0*x186*x192))+((px*x186*x193))+(((-1.0)*x187*x198))+(((-0.03)*x192))+(((-1.0)*r00*sj1*x189))+((x194*x195))+(((-2.0)*x192*x196))+(((-1.0)*x183*x187))+(((0.206)*x188*x196))+(((-0.03)*px*r00))+(((-0.03)*py*r01))+(((-1.0)*sj0*x185*x186))+((x182*x190))+(((0.206)*sj1*x185))+(((-1.0)*cj0*x188*x189))+((x182*x187))+(((0.028028)*(IKcos(j3))))+((x183*x190)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[2];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j2eval[0]=((-1.07224917939204)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-30053.0)+(((-28028.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x199=(cj0*px);
IkReal x200=((98000.0)*sj1);
IkReal x201=(py*sj0);
IkReal x202=((98000.0)*cj1);
IkReal x203=((143000.0)*sj3);
IkReal x204=((1430.0)*cj1);
IkReal x205=((1430.0)*sj1);
IkReal x206=((143000.0)*cj1*cj3);
IkReal x207=((143000.0)*cj3*sj1);
CheckValue<IkReal> x208=IKPowWithIntegerCheck(IKsign(((-30053.0)+(((-28028.0)*cj3)))),-1);
if(!x208.valid){
continue;
}
CheckValue<IkReal> x209 = IKatan2WithCheck(IkReal((((sj3*x205))+(((-1.0)*x201*x202))+(((-1.0)*x201*x206))+((sj1*x201*x203))+((pz*x200))+((pz*x207))+(((-980.0)*cj1))+(((-1.0)*x199*x206))+(((-1.0)*x199*x202))+((sj1*x199*x203))+((cj1*pz*x203))+(((-1.0)*cj3*x204))+(((-14729.0)*sj3)))),IkReal(((10094.0)+(((-1.0)*x200*x201))+(((-1.0)*x201*x207))+(((14729.0)*cj3))+(((-1.0)*pz*x202))+(((-1.0)*pz*x206))+(((-1.0)*cj1*x199*x203))+(((-980.0)*sj1))+(((-1.0)*x199*x207))+(((-1.0)*x199*x200))+(((-1.0)*cj1*x201*x203))+(((-1.0)*cj3*x205))+(((-1.0)*sj3*x204))+((pz*sj1*x203)))),IKFAST_ATAN2_MAGTHRESH);
if(!x209.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x208.value)))+(x209.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x210=IKcos(j2);
IkReal x211=IKsin(j2);
IkReal x212=(px*sj1);
IkReal x213=(r00*sj0);
IkReal x214=(py*sj1);
IkReal x215=(cj1*r02);
IkReal x216=((1.0)*px);
IkReal x217=((0.143)*cj3);
IkReal x218=((0.01)*cj1);
IkReal x219=(cj0*r01);
IkReal x220=(cj1*pz);
IkReal x221=((0.01)*sj1);
IkReal x222=((0.015)*cj1);
IkReal x223=(cj0*r00);
IkReal x224=(pz*sj1);
IkReal x225=(r01*sj0);
IkReal x226=((0.015)*sj1);
IkReal x227=(cj1*py);
IkReal x228=((0.143)*sj3);
IkReal x229=((0.098)*x211);
IkReal x230=((0.098)*x210);
IkReal x231=(x211*x217);
IkReal x232=(x210*x228);
IkReal x233=(x210*x217);
IkReal x234=(x211*x228);
IkReal x235=(x233+x230);
IkReal x236=(x229+x232+x231);
evalcond[0]=((-0.103)+((cj0*x212))+(((-1.0)*x235))+x221+x220+x234+((sj0*x214)));
evalcond[1]=((((-1.0)*sj0*x227))+x224+x236+(((-1.0)*cj0*cj1*x216))+(((-1.0)*x218)));
evalcond[2]=((((-1.0)*x213*x224))+((r02*sj0*x212))+((x213*x218))+((r00*x227))+(((-1.0)*x222*x223))+(((-1.0)*x222*x225))+(((-1.0)*cj0*r02*x214))+(((-1.0)*x218*x219))+((x219*x224))+x236+(((-1.0)*cj1*r01*x216))+((r02*x226)));
evalcond[3]=(((cj0*py*x215))+(((-0.103)*x213))+(((-1.0)*x225*x226))+(((-0.015)*x215))+((x213*x220))+((x213*x221))+(((-1.0)*x219*x221))+(((0.103)*x219))+(((-1.0)*x234))+x235+(((-1.0)*x223*x226))+(((-1.0)*r01*x212))+(((-1.0)*x219*x220))+((r00*x214))+(((-1.0)*sj0*x215*x216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x237=(cj0*px);
IkReal x238=(cj0*r00);
IkReal x239=(r01*sj0);
IkReal x240=((7.34979306407878)*sj1);
IkReal x241=((51.5)*sj1);
IkReal x242=(py*sj0);
CheckValue<IkReal> x243=IKPowWithIntegerCheck(cj4,-1);
if(!x243.valid){
continue;
}
if( IKabs(((0.0204081632653061)*(x243.value)*(((((500.0)*pz*r02))+(((5.0)*x239))+(((5.0)*x238))+(((500.0)*py*r01))+(((-7.5)*cj0*r01))+(((-51.5)*cj1*r02))+(((-1.0)*x238*x241))+(((7.5)*r00*sj0))+(((500.0)*px*r00))+(((-1.0)*x239*x241)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.682139289282146)+(((0.713572142143571)*x237))+(((-1.0)*x237*x240))+(((-7.34979306407878)*cj1*pz))+(((35.6786071071785)*(px*px)))+(((-1.0)*x240*x242))+(((1.07035821321536)*px*sj0))+(((35.6786071071785)*(pz*pz)))+(((35.6786071071785)*(py*py)))+(((-0.0734979306407878)*sj1))+(((0.713572142143571)*x242))+(((-1.07035821321536)*cj0*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0204081632653061)*(x243.value)*(((((500.0)*pz*r02))+(((5.0)*x239))+(((5.0)*x238))+(((500.0)*py*r01))+(((-7.5)*cj0*r01))+(((-51.5)*cj1*r02))+(((-1.0)*x238*x241))+(((7.5)*r00*sj0))+(((500.0)*px*r00))+(((-1.0)*x239*x241))))))+IKsqr(((-0.682139289282146)+(((0.713572142143571)*x237))+(((-1.0)*x237*x240))+(((-7.34979306407878)*cj1*pz))+(((35.6786071071785)*(px*px)))+(((-1.0)*x240*x242))+(((1.07035821321536)*px*sj0))+(((35.6786071071785)*(pz*pz)))+(((35.6786071071785)*(py*py)))+(((-0.0734979306407878)*sj1))+(((0.713572142143571)*x242))+(((-1.07035821321536)*cj0*py))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.0204081632653061)*(x243.value)*(((((500.0)*pz*r02))+(((5.0)*x239))+(((5.0)*x238))+(((500.0)*py*r01))+(((-7.5)*cj0*r01))+(((-51.5)*cj1*r02))+(((-1.0)*x238*x241))+(((7.5)*r00*sj0))+(((500.0)*px*r00))+(((-1.0)*x239*x241))))), ((-0.682139289282146)+(((0.713572142143571)*x237))+(((-1.0)*x237*x240))+(((-7.34979306407878)*cj1*pz))+(((35.6786071071785)*(px*px)))+(((-1.0)*x240*x242))+(((1.07035821321536)*px*sj0))+(((35.6786071071785)*(pz*pz)))+(((35.6786071071785)*(py*py)))+(((-0.0734979306407878)*sj1))+(((0.713572142143571)*x242))+(((-1.07035821321536)*cj0*py))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x244=IKcos(j3);
IkReal x245=pz*pz;
IkReal x246=py*py;
IkReal x247=px*px;
IkReal x248=(cj0*r00);
IkReal x249=(cj0*r02);
IkReal x250=((1.0)*px);
IkReal x251=((0.00206)*sj1);
IkReal x252=((0.103)*sj1);
IkReal x253=(py*sj0);
IkReal x254=(cj0*r01);
IkReal x255=((0.206)*cj1);
IkReal x256=(r00*sj0);
IkReal x257=((0.03)*py);
IkReal x258=(cj1*r02);
IkReal x259=(r01*sj0);
IkReal x260=(px*r01);
IkReal x261=((0.206)*sj1);
IkReal x262=((1.0)*r02);
IkReal x263=((0.03)*px);
IkReal x264=(pz*r02);
IkReal x265=((0.098)*cj4);
IkReal x266=((2.0)*py);
IkReal x267=(py*r00);
IkReal x268=((0.103)*cj1);
IkReal x269=(cj0*px);
IkReal x270=((0.00309)*sj1);
IkReal x271=(px*sj0);
IkReal x272=((0.028028)*x244);
IkReal x273=((1.0)*x245);
IkReal x274=((1.0)*x247);
evalcond[0]=(((pz*x259))+(((-1.0)*x259*x268))+((x244*x265))+(((-1.0)*x253*x262))+(((-1.0)*x249*x250))+(((-0.01)*r02))+((pz*x248))+((r02*x252))+(((0.143)*cj4))+(((-1.0)*x248*x268)));
evalcond[1]=((((0.103)*x258))+((x248*x252))+(((0.015)*x254))+(((-0.01)*x259))+(((-1.0)*r00*x250))+(((-0.015)*x256))+((x265*(IKsin(j3))))+(((-1.0)*py*r01))+((x252*x259))+(((-0.01)*x248))+(((-1.0)*pz*x262)));
evalcond[2]=((0.019119)+(((-0.02)*x253))+((x253*x261))+(((-1.0)*x246))+((pz*x255))+(((-0.02)*x269))+x251+x272+((cj0*x257))+(((-1.0)*sj0*x263))+(((-1.0)*x274))+(((-1.0)*x273))+((x261*x269)));
evalcond[3]=(((x246*x254))+((x246*x256))+(((-1.0)*pz*x255*x256))+(((0.02)*x267))+((x245*x256))+((px*x248*x266))+((x259*x270))+(((-1.0)*x251*x256))+((x260*x261))+((x248*x270))+((x251*x254))+(((-0.010484)*x254))+(((-1.0)*sj4*x272))+(((-2.0)*x253*x260))+(((-0.02)*x260))+((pz*x249*x266))+(((-1.0)*py*x249*x255))+(((-1.0)*x261*x267))+(((-0.0003)*x259))+(((-1.0)*r00*x263))+(((-1.0)*r01*x257))+(((-0.0003)*x248))+(((0.00309)*x258))+(((-0.03)*x264))+((r02*x255*x271))+(((0.010484)*x256))+(((-2.0)*x264*x271))+(((-1.0)*x254*x274))+(((-1.0)*x254*x273))+(((-1.0)*x256*x274))+(((-0.030053)*sj4))+((pz*x254*x255)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[2];
j2eval[0]=cj4;
j2eval[1]=IKsign(cj4);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x275=(cj3*cj4);
j2eval[0]=((((-1.45918367346939)*cj4))+(((-1.0)*x275)));
j2eval[1]=IKsign(((((-98.0)*x275))+(((-143.0)*cj4))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=cj4;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j2eval[0]=((-1.07224917939204)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-30053.0)+(((-28028.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x276=(cj0*px);
IkReal x277=((98000.0)*sj1);
IkReal x278=(py*sj0);
IkReal x279=((98000.0)*cj1);
IkReal x280=((143000.0)*sj3);
IkReal x281=((1430.0)*cj1);
IkReal x282=((1430.0)*sj1);
IkReal x283=((143000.0)*cj1*cj3);
IkReal x284=((143000.0)*cj3*sj1);
CheckValue<IkReal> x285 = IKatan2WithCheck(IkReal((((sj1*x276*x280))+((sj1*x278*x280))+(((-1.0)*x276*x283))+(((-1.0)*cj3*x281))+((cj1*pz*x280))+((sj3*x282))+(((-980.0)*cj1))+(((-1.0)*x278*x279))+((pz*x277))+(((-14729.0)*sj3))+((pz*x284))+(((-1.0)*x278*x283))+(((-1.0)*x276*x279)))),IkReal(((10094.0)+(((-1.0)*pz*x279))+(((-1.0)*cj1*x276*x280))+(((-1.0)*x277*x278))+(((-1.0)*sj3*x281))+(((14729.0)*cj3))+(((-1.0)*x276*x284))+(((-1.0)*cj3*x282))+(((-980.0)*sj1))+((pz*sj1*x280))+(((-1.0)*pz*x283))+(((-1.0)*cj1*x278*x280))+(((-1.0)*x278*x284))+(((-1.0)*x276*x277)))),IKFAST_ATAN2_MAGTHRESH);
if(!x285.valid){
continue;
}
CheckValue<IkReal> x286=IKPowWithIntegerCheck(IKsign(((-30053.0)+(((-28028.0)*cj3)))),-1);
if(!x286.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x285.value)+(((1.5707963267949)*(x286.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x287=IKcos(j2);
IkReal x288=IKsin(j2);
IkReal x289=(px*sj1);
IkReal x290=(r00*sj0);
IkReal x291=(py*sj1);
IkReal x292=(cj1*r02);
IkReal x293=((1.0)*px);
IkReal x294=((0.143)*cj3);
IkReal x295=((0.01)*cj1);
IkReal x296=(cj0*r01);
IkReal x297=(cj1*pz);
IkReal x298=((0.01)*sj1);
IkReal x299=((0.015)*cj1);
IkReal x300=(cj0*r00);
IkReal x301=(pz*sj1);
IkReal x302=(r01*sj0);
IkReal x303=((0.015)*sj1);
IkReal x304=(cj1*py);
IkReal x305=((0.143)*sj3);
IkReal x306=((0.098)*x288);
IkReal x307=((0.098)*x287);
IkReal x308=(x288*x294);
IkReal x309=(x287*x305);
IkReal x310=(x288*x305);
IkReal x311=(x287*x294);
IkReal x312=(x307+x311);
IkReal x313=(x308+x309+x306);
evalcond[0]=((-0.103)+((sj0*x291))+((cj0*x289))+x310+x298+x297+(((-1.0)*x312)));
evalcond[1]=((((-1.0)*x295))+x301+x313+(((-1.0)*cj0*cj1*x293))+(((-1.0)*sj0*x304)));
evalcond[2]=(((x290*x295))+(((-1.0)*cj1*r01*x293))+((r02*x303))+((r02*sj0*x289))+(((-1.0)*cj0*r02*x291))+(((-1.0)*x313))+(((-1.0)*x290*x301))+(((-1.0)*x299*x302))+(((-1.0)*x299*x300))+((x296*x301))+(((-1.0)*x295*x296))+((r00*x304)));
evalcond[3]=(((x290*x297))+((x290*x298))+(((0.103)*x296))+(((-1.0)*x296*x298))+(((-1.0)*x302*x303))+((cj0*py*x292))+(((-0.103)*x290))+x310+(((-1.0)*x312))+((r00*x291))+(((-1.0)*r01*x289))+(((-0.015)*x292))+(((-1.0)*x296*x297))+(((-1.0)*x300*x303))+(((-1.0)*sj0*x292*x293)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j2eval[0]=((-1.07224917939204)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-30053.0)+(((-28028.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x314=(cj0*px);
IkReal x315=((98000.0)*sj1);
IkReal x316=(py*sj0);
IkReal x317=((98000.0)*cj1);
IkReal x318=((143000.0)*sj3);
IkReal x319=((1430.0)*cj1);
IkReal x320=((1430.0)*sj1);
IkReal x321=((143000.0)*cj1*cj3);
IkReal x322=((143000.0)*cj3*sj1);
CheckValue<IkReal> x323=IKPowWithIntegerCheck(IKsign(((-30053.0)+(((-28028.0)*cj3)))),-1);
if(!x323.valid){
continue;
}
CheckValue<IkReal> x324 = IKatan2WithCheck(IkReal(((((-1.0)*x314*x321))+((pz*x322))+((cj1*pz*x318))+((sj3*x320))+(((-1.0)*x316*x321))+((sj1*x316*x318))+(((-980.0)*cj1))+((sj1*x314*x318))+((pz*x315))+(((-1.0)*x314*x317))+(((-14729.0)*sj3))+(((-1.0)*cj3*x319))+(((-1.0)*x316*x317)))),IkReal(((10094.0)+(((-1.0)*cj3*x320))+((pz*sj1*x318))+(((-1.0)*x314*x322))+(((14729.0)*cj3))+(((-1.0)*sj3*x319))+(((-980.0)*sj1))+(((-1.0)*cj1*x314*x318))+(((-1.0)*x316*x322))+(((-1.0)*pz*x317))+(((-1.0)*x315*x316))+(((-1.0)*cj1*x316*x318))+(((-1.0)*x314*x315))+(((-1.0)*pz*x321)))),IKFAST_ATAN2_MAGTHRESH);
if(!x324.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x323.value)))+(x324.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x325=IKcos(j2);
IkReal x326=IKsin(j2);
IkReal x327=(px*sj1);
IkReal x328=(r00*sj0);
IkReal x329=(py*sj1);
IkReal x330=(cj1*r02);
IkReal x331=((1.0)*px);
IkReal x332=((0.143)*cj3);
IkReal x333=((0.01)*cj1);
IkReal x334=(cj0*r01);
IkReal x335=(cj1*pz);
IkReal x336=((0.01)*sj1);
IkReal x337=((0.015)*cj1);
IkReal x338=(cj0*r00);
IkReal x339=(pz*sj1);
IkReal x340=(r01*sj0);
IkReal x341=((0.015)*sj1);
IkReal x342=(cj1*py);
IkReal x343=((0.143)*sj3);
IkReal x344=((0.098)*x326);
IkReal x345=((0.098)*x325);
IkReal x346=(x326*x332);
IkReal x347=(x325*x343);
IkReal x348=(x325*x332);
IkReal x349=(x326*x343);
IkReal x350=(x345+x348);
IkReal x351=(x346+x347+x344);
evalcond[0]=((-0.103)+(((-1.0)*x350))+x336+x335+x349+((cj0*x327))+((sj0*x329)));
evalcond[1]=((((-1.0)*cj0*cj1*x331))+x339+x351+(((-1.0)*sj0*x342))+(((-1.0)*x333)));
evalcond[2]=((((-1.0)*x337*x338))+(((-1.0)*cj0*r02*x329))+((x334*x339))+((r00*x342))+(((-1.0)*x328*x339))+(((-1.0)*x333*x334))+((r02*sj0*x327))+(((-1.0)*x337*x340))+x351+((r02*x341))+(((-1.0)*cj1*r01*x331))+((x328*x333)));
evalcond[3]=((((-1.0)*r01*x327))+(((-1.0)*sj0*x330*x331))+((r00*x329))+(((-0.015)*x330))+x350+(((-0.103)*x328))+(((-1.0)*x340*x341))+((x328*x335))+((x328*x336))+((cj0*py*x330))+(((-1.0)*x349))+(((-1.0)*x338*x341))+(((-1.0)*x334*x335))+(((-1.0)*x334*x336))+(((0.103)*x334)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x352=((4.149377593361)*cj1);
IkReal x353=(cj0*px);
IkReal x354=(py*sj0);
IkReal x355=((4.149377593361)*sj1);
if( IKabs((((x352*x354))+((x352*x353))+(((0.04149377593361)*cj1))+(((-1.0)*pz*x355)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.427385892116183)+(((0.04149377593361)*sj1))+((x353*x355))+((pz*x352))+((x354*x355)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x352*x354))+((x352*x353))+(((0.04149377593361)*cj1))+(((-1.0)*pz*x355))))+IKsqr(((-0.427385892116183)+(((0.04149377593361)*sj1))+((x353*x355))+((pz*x352))+((x354*x355))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x352*x354))+((x352*x353))+(((0.04149377593361)*cj1))+(((-1.0)*pz*x355))), ((-0.427385892116183)+(((0.04149377593361)*sj1))+((x353*x355))+((pz*x352))+((x354*x355))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x356=IKcos(j2);
IkReal x357=IKsin(j2);
IkReal x358=py*py;
IkReal x359=px*px;
IkReal x360=pz*pz;
IkReal x361=(r01*sj0);
IkReal x362=(py*sj1);
IkReal x363=((1.0)*cj1);
IkReal x364=((1.0)*sj1);
IkReal x365=((0.02)*cj1);
IkReal x366=(px*r00);
IkReal x367=(py*sj0);
IkReal x368=((2.0)*pz);
IkReal x369=((0.01)*cj1);
IkReal x370=(r00*sj0);
IkReal x371=(cj1*pz);
IkReal x372=((0.01)*sj1);
IkReal x373=(cj0*r01);
IkReal x374=(pz*sj1);
IkReal x375=(pz*r02);
IkReal x376=(px*r01);
IkReal x377=((2.0)*cj1);
IkReal x378=(cj0*r00);
IkReal x379=(cj1*py);
IkReal x380=((0.03)*r00);
IkReal x381=((0.015)*sj1);
IkReal x382=(r02*sj0);
IkReal x383=(px*sj1);
IkReal x384=((0.02)*sj1);
IkReal x385=(cj0*r02);
IkReal x386=((0.010734)*cj1);
IkReal x387=(py*r01);
IkReal x388=(cj1*r02);
IkReal x389=((0.206)*pz);
IkReal x390=(r02*sj1);
IkReal x391=((0.015)*cj1);
IkReal x392=((0.0003)*cj1);
IkReal x393=((0.0003)*sj1);
IkReal x394=((0.03)*cj1);
IkReal x395=((0.010484)*sj1);
IkReal x396=(cj4*x357);
IkReal x397=(px*x385);
IkReal x398=(cj4*x356);
IkReal x399=(r02*x359);
IkReal x400=((0.241)*x356);
IkReal x401=((0.241)*x357);
IkReal x402=(sj1*x360);
IkReal x403=(sj1*x358);
IkReal x404=(r02*x360);
evalcond[0]=((((-1.0)*x396))+((sj1*x378))+((sj1*x361))+x388);
evalcond[1]=((((-1.0)*x363*x378))+(((-1.0)*x398))+(((-1.0)*x361*x363))+x390);
evalcond[2]=((-0.103)+((sj0*x362))+x372+x371+((cj0*x383))+(((-1.0)*x400)));
evalcond[3]=((((-1.0)*x363*x367))+(((-1.0)*x369))+(((-1.0)*cj0*px*x363))+x374+x401);
evalcond[4]=((((-1.0)*x362*x385))+(((-1.0)*x363*x376))+(((-1.0)*x361*x391))+(((-1.0)*x378*x391))+((x369*x370))+((r00*x379))+((r02*x381))+(((-1.0)*pz*x364*x370))+(((-1.0)*sj4*x401))+((x382*x383))+(((-1.0)*x369*x373))+((x373*x374)));
evalcond[5]=(((x370*x372))+((x370*x371))+(((-0.103)*x370))+(((-1.0)*x372*x373))+((r00*x362))+(((-0.015)*x388))+(((0.103)*x373))+(((-1.0)*pz*x363*x373))+(((-1.0)*sj4*x400))+((x379*x385))+(((-1.0)*px*x363*x382))+(((-1.0)*x361*x381))+(((-1.0)*x378*x381))+(((-1.0)*x364*x376)));
evalcond[6]=(((x378*x389))+((cj1*x358*x361))+((x366*x367*x377))+(((-1.0)*x358*x363*x378))+(((-0.206)*r02*x367))+((x361*x389))+(((0.03)*x382*x383))+(((0.010934)*x390))+(((-0.00206)*r02))+((x358*x390))+(((-0.02)*x361*x374))+(((0.02)*x383*x385))+(((-1.0)*sj1*x366*x368))+(((-0.206)*x397))+((x365*x375))+((x365*x366))+(((-1.0)*x364*x404))+(((-1.0)*x373*x392))+(((0.03)*x373*x374))+(((-0.058081)*x398))+(((-1.0)*x360*x361*x363))+(((-0.03)*x370*x374))+((x379*x380))+(((-1.0)*x361*x386))+((x359*x390))+((x365*x387))+((cj1*x359*x378))+(((-1.0)*x360*x363*x378))+(((-1.0)*x378*x386))+(((0.02)*x362*x382))+((x367*x368*x388))+(((-1.0)*r01*x362*x368))+(((-0.03)*x362*x385))+(((-1.0)*x376*x394))+(((-1.0)*x359*x361*x363))+((cj1*x368*x397))+((x370*x392))+(((-0.02)*x374*x378))+((px*py*x373*x377)));
evalcond[7]=(((r02*x365*x367))+(((-1.0)*x361*x395))+(((-1.0)*x378*x395))+(((-1.0)*r01*x368*x379))+((x359*x388))+((x361*x402))+((px*x382*x394))+(((-1.0)*x370*x393))+((x365*x397))+(((-0.03)*x379*x385))+(((-1.0)*cj1*x366*x368))+(((-2.0)*px*x362*x373))+(((-1.0)*pz*x365*x378))+(((-0.058081)*x396))+(((-0.00309)*x373))+(((-0.03)*x370*x371))+(((0.03)*x371*x373))+(((-1.0)*x362*x368*x382))+((sj1*x359*x361))+(((-1.0)*x362*x380))+(((0.206)*x366))+(((0.206)*x375))+(((-1.0)*pz*x361*x365))+((x373*x393))+(((-1.0)*x359*x364*x378))+((x358*x388))+(((0.00309)*x370))+(((-1.0)*x358*x361*x364))+(((-0.02)*r01*x362))+(((-0.010284)*x388))+(((-1.0)*x368*x383*x385))+(((0.00206)*x378))+(((-2.0)*sj0*x362*x366))+(((-0.02)*r02*x374))+(((0.00206)*x361))+(((-1.0)*x363*x404))+(((0.03)*sj1*x376))+(((-1.0)*x366*x384))+(((0.206)*x387))+((x378*x403))+((x378*x402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x405=((22.2222222222222)*cj1);
IkReal x406=(py*sj0);
IkReal x407=((22.2222222222222)*sj1);
IkReal x408=(cj0*px);
if( IKabs((((pz*x407))+(((-0.222222222222222)*cj1))+(((-1.0)*x405*x408))+(((-1.0)*x405*x406)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.28888888888889)+(((-1.0)*x406*x407))+(((-1.0)*x407*x408))+(((-1.0)*pz*x405))+(((-0.222222222222222)*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((pz*x407))+(((-0.222222222222222)*cj1))+(((-1.0)*x405*x408))+(((-1.0)*x405*x406))))+IKsqr(((2.28888888888889)+(((-1.0)*x406*x407))+(((-1.0)*x407*x408))+(((-1.0)*pz*x405))+(((-0.222222222222222)*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((pz*x407))+(((-0.222222222222222)*cj1))+(((-1.0)*x405*x408))+(((-1.0)*x405*x406))), ((2.28888888888889)+(((-1.0)*x406*x407))+(((-1.0)*x407*x408))+(((-1.0)*pz*x405))+(((-0.222222222222222)*sj1))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x409=IKcos(j2);
IkReal x410=IKsin(j2);
IkReal x411=py*py;
IkReal x412=px*px;
IkReal x413=pz*pz;
IkReal x414=(r01*sj0);
IkReal x415=(py*sj1);
IkReal x416=((1.0)*cj1);
IkReal x417=((1.0)*sj1);
IkReal x418=((0.02)*cj1);
IkReal x419=(px*r00);
IkReal x420=(py*sj0);
IkReal x421=((0.002025)*cj4);
IkReal x422=((0.01)*cj1);
IkReal x423=(pz*r01);
IkReal x424=(r00*sj0);
IkReal x425=(cj1*pz);
IkReal x426=((0.01)*sj1);
IkReal x427=(cj0*r01);
IkReal x428=(pz*sj1);
IkReal x429=(pz*r02);
IkReal x430=(cj0*sj1);
IkReal x431=((0.03)*cj1);
IkReal x432=(px*r01);
IkReal x433=((2.0)*cj1);
IkReal x434=(cj0*r00);
IkReal x435=(py*r00);
IkReal x436=(cj1*r02);
IkReal x437=(r02*sj0);
IkReal x438=(px*sj1);
IkReal x439=((2.0)*sj0);
IkReal x440=((0.02)*sj1);
IkReal x441=(cj0*py);
IkReal x442=((0.010734)*cj1);
IkReal x443=(py*r01);
IkReal x444=(r02*sj1);
IkReal x445=(cj0*r02);
IkReal x446=((0.206)*pz);
IkReal x447=((0.015)*cj1);
IkReal x448=((0.0003)*cj1);
IkReal x449=((0.0003)*sj1);
IkReal x450=(px*x445);
IkReal x451=((0.045)*x409);
IkReal x452=(sj1*x412);
IkReal x453=((0.045)*x410);
IkReal x454=(r02*x413);
evalcond[0]=(((sj1*x414))+((cj4*x410))+x436+((r00*x430)));
evalcond[1]=((((-1.0)*x416*x434))+((cj4*x409))+x444+(((-1.0)*x414*x416)));
evalcond[2]=((-0.103)+((px*x430))+((sj0*x415))+x426+x425+x451);
evalcond[3]=((((-1.0)*cj0*px*x416))+(((-1.0)*x416*x420))+(((-1.0)*x422))+(((-1.0)*x453))+x428);
evalcond[4]=((((-1.0)*x422*x427))+((cj1*x435))+(((-1.0)*x416*x432))+(((-1.0)*x434*x447))+((sj4*x453))+(((0.015)*x444))+((x423*x430))+(((-1.0)*x414*x447))+(((-1.0)*x415*x445))+((x437*x438))+((x422*x424))+(((-1.0)*pz*x417*x424)));
evalcond[5]=((((-1.0)*cj0*x416*x423))+((x424*x426))+((x424*x425))+(((0.103)*x427))+(((-0.015)*x436))+((sj4*x451))+(((-1.0)*px*x416*x437))+(((-1.0)*x426*x427))+((r00*x415))+(((-0.103)*x424))+(((-0.015)*r00*x430))+(((-1.0)*x417*x432))+(((-0.015)*sj1*x414))+((x436*x441)));
evalcond[6]=(((x419*x420*x433))+((px*py*x427*x433))+(((-1.0)*x427*x448))+((x424*x448))+((x434*x446))+(((0.03)*x423*x430))+(((-1.0)*x411*x416*x434))+(((-2.0)*x415*x423))+((x414*x446))+(((-0.02)*x414*x428))+(((-1.0)*x431*x432))+(((-0.00206)*r02))+(((-1.0)*x434*x442))+(((0.02)*px*r02*x430))+((cj1*x411*x414))+(((-1.0)*x417*x454))+((x411*x444))+(((-0.03)*x424*x428))+(((0.03)*x437*x438))+(((2.0)*r02*x420*x425))+((x409*x421))+(((-0.206)*r02*x420))+((x412*x444))+((x418*x429))+(((2.0)*x425*x450))+(((-2.0)*x419*x428))+(((-1.0)*x412*x414*x416))+(((0.010934)*x444))+((x418*x443))+(((-1.0)*x414*x442))+((x431*x435))+(((-1.0)*x413*x416*x434))+(((-0.02)*x428*x434))+((cj1*x412*x434))+((x418*x419))+(((-1.0)*x413*x414*x416))+(((-0.03)*x415*x445))+(((0.02)*x415*x437))+(((-0.206)*x450)));
evalcond[7]=((((-0.02)*r02*x428))+((r00*x411*x430))+(((0.00206)*x434))+(((-1.0)*x411*x414*x417))+((x418*x450))+((sj1*x413*x414))+(((-1.0)*x415*x429*x439))+(((-0.010484)*sj1*x414))+((x410*x421))+(((0.206)*x419))+(((-1.0)*pz*x418*x434))+(((0.00206)*x414))+(((0.03)*sj1*x432))+(((-1.0)*x415*x419*x439))+(((-0.00309)*x427))+(((-1.0)*x412*x417*x434))+(((-0.03)*x424*x425))+((r02*x418*x420))+(((-2.0)*px*x415*x427))+((x412*x436))+(((-2.0)*x419*x425))+((x411*x436))+(((0.206)*x443))+(((-1.0)*py*x423*x433))+(((-1.0)*x424*x449))+(((-0.03)*r00*x415))+(((-0.02)*r01*x415))+(((-0.010484)*r00*x430))+(((-0.010284)*x436))+(((0.00309)*x424))+(((0.206)*x429))+(((-2.0)*x428*x450))+(((-1.0)*x416*x454))+((px*x431*x437))+(((-1.0)*r02*x431*x441))+(((-1.0)*pz*x414*x418))+((cj0*x423*x431))+((r00*x413*x430))+((x427*x449))+(((-1.0)*x419*x440))+((x414*x452)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x468=IKPowWithIntegerCheck(cj4,-1);
if(!x468.valid){
continue;
}
IkReal x455=x468.value;
IkReal x456=(cj1*cj3);
IkReal x457=((10.0)*cj4);
IkReal x458=(cj1*r02);
IkReal x459=((143.0)*sj1);
IkReal x460=(r01*sj0);
IkReal x461=((1000.0)*cj4);
IkReal x462=(pz*sj1);
IkReal x463=(cj0*px);
IkReal x464=(cj0*r00);
IkReal x465=((98.0)*sj1);
IkReal x466=(py*sj0);
IkReal x467=((-0.0102040816326531)*x455);
CheckValue<IkReal> x469=IKPowWithIntegerCheck(sj3,-1);
if(!x469.valid){
continue;
}
if( IKabs((x467*((((x461*x462))+(((143.0)*x458))+(((-1.0)*cj1*x461*x463))+(((-1.0)*cj1*x461*x466))+(((-1.0)*cj1*x457))+((x459*x464))+((x459*x460)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x467*(x469.value)*(((((-98.0)*x458))+(((-1.0)*x460*x465))+(((-1.0)*x464*x465))+(((-1.0)*cj3*x459*x460))+(((-1.0)*cj3*x459*x464))+(((-1.0)*cj3*x461*x462))+((x456*x461*x466))+((x456*x461*x463))+(((-143.0)*r02*x456))+((x456*x457)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x467*((((x461*x462))+(((143.0)*x458))+(((-1.0)*cj1*x461*x463))+(((-1.0)*cj1*x461*x466))+(((-1.0)*cj1*x457))+((x459*x464))+((x459*x460))))))+IKsqr((x467*(x469.value)*(((((-98.0)*x458))+(((-1.0)*x460*x465))+(((-1.0)*x464*x465))+(((-1.0)*cj3*x459*x460))+(((-1.0)*cj3*x459*x464))+(((-1.0)*cj3*x461*x462))+((x456*x461*x466))+((x456*x461*x463))+(((-143.0)*r02*x456))+((x456*x457))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x467*((((x461*x462))+(((143.0)*x458))+(((-1.0)*cj1*x461*x463))+(((-1.0)*cj1*x461*x466))+(((-1.0)*cj1*x457))+((x459*x464))+((x459*x460))))), (x467*(x469.value)*(((((-98.0)*x458))+(((-1.0)*x460*x465))+(((-1.0)*x464*x465))+(((-1.0)*cj3*x459*x460))+(((-1.0)*cj3*x459*x464))+(((-1.0)*cj3*x461*x462))+((x456*x461*x466))+((x456*x461*x463))+(((-143.0)*r02*x456))+((x456*x457))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x470=IKsin(j2);
IkReal x471=IKcos(j2);
IkReal x472=py*py;
IkReal x473=px*px;
IkReal x474=pz*pz;
IkReal x475=(r01*sj0);
IkReal x476=(py*sj1);
IkReal x477=((1.0)*cj1);
IkReal x478=((1.0)*sj1);
IkReal x479=((0.02)*cj1);
IkReal x480=(px*r00);
IkReal x481=(py*sj0);
IkReal x482=((2.0)*pz);
IkReal x483=((0.01)*cj1);
IkReal x484=(r00*sj0);
IkReal x485=(cj1*pz);
IkReal x486=((0.01)*sj1);
IkReal x487=(cj0*r01);
IkReal x488=(pz*sj1);
IkReal x489=(pz*r02);
IkReal x490=(cj0*r00);
IkReal x491=((0.010734)*cj1);
IkReal x492=((1.0)*cj4);
IkReal x493=(px*r01);
IkReal x494=((2.0)*cj1);
IkReal x495=(cj1*py);
IkReal x496=((0.03)*r00);
IkReal x497=((0.015)*sj1);
IkReal x498=(cj0*r02);
IkReal x499=(px*sj1);
IkReal x500=(r02*sj0);
IkReal x501=((0.143)*cj3);
IkReal x502=((0.02)*sj1);
IkReal x503=(py*r01);
IkReal x504=(cj1*r02);
IkReal x505=((0.206)*pz);
IkReal x506=((0.010845)*sj3);
IkReal x507=(r02*sj1);
IkReal x508=((0.015)*cj1);
IkReal x509=((0.0003)*cj1);
IkReal x510=((0.0003)*sj1);
IkReal x511=((0.03)*cj1);
IkReal x512=((0.010484)*sj1);
IkReal x513=(px*x498);
IkReal x514=(cj3*x470);
IkReal x515=(cj4*x471);
IkReal x516=(r02*x473);
IkReal x517=(sj4*x471);
IkReal x518=(sj1*x474);
IkReal x519=(cj4*x470);
IkReal x520=(sj1*x472);
IkReal x521=(sj3*x471);
IkReal x522=((0.098)*x470);
IkReal x523=(r02*x474);
IkReal x524=((0.143)*sj3*x470);
evalcond[0]=((((-1.0)*x492*x514))+((sj1*x490))+(((-1.0)*x492*x521))+x504+((sj1*x475)));
evalcond[1]=((((-1.0)*x475*x477))+(((-1.0)*cj3*x471*x492))+x507+((sj3*x519))+(((-1.0)*x477*x490)));
evalcond[2]=((-0.103)+(((-1.0)*x471*x501))+(((-0.098)*x471))+((cj0*x499))+x485+x486+x524+((sj0*x476)));
evalcond[3]=((((-1.0)*x483))+(((-1.0)*cj0*px*x477))+x488+x522+(((0.143)*x521))+(((-1.0)*x477*x481))+((x470*x501)));
evalcond[4]=((((-1.0)*x476*x498))+(((-1.0)*x483*x487))+((r02*x497))+((x483*x484))+(((-1.0)*sj4*x522))+(((-0.143)*sj3*x517))+(((-1.0)*x475*x508))+(((-1.0)*pz*x478*x484))+(((-1.0)*x490*x508))+((r00*x495))+(((-1.0)*sj4*x470*x501))+((x499*x500))+(((-1.0)*x477*x493))+((x487*x488)));
evalcond[5]=((((-1.0)*x486*x487))+(((-1.0)*x501*x517))+((x484*x486))+((x484*x485))+(((-1.0)*pz*x477*x487))+(((-1.0)*px*x477*x500))+(((-0.098)*x517))+((x495*x498))+(((-0.103)*x484))+(((-1.0)*x490*x497))+(((0.103)*x487))+(((-0.015)*x504))+((sj4*x524))+(((-1.0)*x478*x493))+((r00*x476))+(((-1.0)*x475*x497)));
evalcond[6]=((((-1.0)*x493*x511))+(((-1.0)*x472*x477*x490))+(((-1.0)*x478*x523))+((x480*x481*x494))+(((0.02)*x476*x500))+(((0.010934)*x507))+((x481*x482*x504))+((cj1*x482*x513))+((x495*x496))+((cj1*x473*x490))+(((-0.00206)*r02))+(((-0.03)*x484*x488))+((x475*x505))+(((-1.0)*r01*x476*x482))+(((-1.0)*x490*x491))+((x490*x505))+(((-0.028028)*x515))+(((-0.206)*x513))+(((-1.0)*x474*x477*x490))+(((0.03)*x499*x500))+((x484*x509))+(((-0.206)*r02*x481))+(((-0.03)*x476*x498))+(((-1.0)*x487*x509))+(((-0.030053)*cj3*x515))+(((0.02)*x498*x499))+(((0.03)*x487*x488))+(((-1.0)*sj1*x480*x482))+(((-0.02)*x475*x488))+((cj1*x472*x475))+((x479*x489))+((x479*x480))+((x506*x519))+((px*py*x487*x494))+(((-1.0)*x473*x475*x477))+((x479*x503))+(((-0.02)*x488*x490))+(((-1.0)*x475*x491))+((x472*x507))+(((-1.0)*x474*x475*x477))+((x473*x507)));
evalcond[7]=((((-0.010284)*x504))+(((-1.0)*x477*x523))+((x487*x510))+(((-1.0)*x475*x512))+(((-0.03)*x495*x498))+(((-1.0)*x476*x482*x500))+(((0.03)*sj1*x493))+((r02*x479*x481))+(((-0.02)*r01*x476))+(((-1.0)*x490*x512))+(((0.03)*x485*x487))+(((0.00309)*x484))+(((-1.0)*pz*x479*x490))+(((-0.030053)*cj4*x514))+(((-0.03)*x484*x485))+(((0.206)*x480))+(((0.206)*x489))+(((0.00206)*x490))+(((-1.0)*pz*x475*x479))+((sj1*x473*x475))+((x479*x513))+(((-1.0)*x482*x498*x499))+(((-1.0)*cj1*x480*x482))+(((-0.028028)*x519))+(((-0.00309)*x487))+(((0.206)*x503))+((x490*x520))+(((-1.0)*x472*x475*x478))+((x475*x518))+(((-1.0)*x480*x502))+(((-1.0)*x506*x515))+(((-0.02)*r02*x488))+(((-2.0)*sj0*x476*x480))+(((0.00206)*x475))+(((-2.0)*px*x476*x487))+((px*x500*x511))+(((-1.0)*x484*x510))+((x490*x518))+((x472*x504))+(((-1.0)*x473*x478*x490))+((x473*x504))+(((-1.0)*r01*x482*x495))+(((-1.0)*x476*x496)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x525=((1000.0)*cj4);
IkReal x526=(cj3*sj1);
IkReal x527=(py*sj0);
IkReal x528=(cj1*sj3);
IkReal x529=((103.0)*cj4);
IkReal x530=((10.0)*cj4);
IkReal x531=(cj0*r00);
IkReal x532=((98.0)*sj1);
IkReal x533=(sj1*sj3);
IkReal x534=(cj0*px);
IkReal x535=((143.0)*r02);
IkReal x536=(r01*sj0);
IkReal x537=(cj1*cj3);
CheckValue<IkReal> x538=IKPowWithIntegerCheck(IKsign(((((-98.0)*cj3*cj4))+(((-143.0)*cj4)))),-1);
if(!x538.valid){
continue;
}
CheckValue<IkReal> x539 = IKatan2WithCheck(IkReal(((((-1.0)*x532*x536))+((x525*x533*x534))+(((-1.0)*sj3*x529))+(((-1.0)*x531*x532))+((x525*x527*x533))+(((-143.0)*x526*x531))+(((-143.0)*x526*x536))+(((-98.0)*cj1*r02))+(((-1.0)*x535*x537))+((pz*x525*x528))+((x530*x533)))),IkReal(((((-1.0)*x525*x526*x534))+(((-1.0)*x525*x526*x527))+(((-1.0)*x526*x530))+(((-1.0)*x528*x535))+(((-143.0)*x533*x536))+(((-143.0)*x531*x533))+(((-1.0)*pz*x525*x537))+((cj3*x529)))),IKFAST_ATAN2_MAGTHRESH);
if(!x539.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x538.value)))+(x539.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x540=IKsin(j2);
IkReal x541=IKcos(j2);
IkReal x542=py*py;
IkReal x543=px*px;
IkReal x544=pz*pz;
IkReal x545=(r01*sj0);
IkReal x546=(py*sj1);
IkReal x547=((1.0)*cj1);
IkReal x548=((1.0)*sj1);
IkReal x549=((0.02)*cj1);
IkReal x550=(px*r00);
IkReal x551=(py*sj0);
IkReal x552=((2.0)*pz);
IkReal x553=((0.01)*cj1);
IkReal x554=(r00*sj0);
IkReal x555=(cj1*pz);
IkReal x556=((0.01)*sj1);
IkReal x557=(cj0*r01);
IkReal x558=(pz*sj1);
IkReal x559=(pz*r02);
IkReal x560=(cj0*r00);
IkReal x561=((0.010734)*cj1);
IkReal x562=((1.0)*cj4);
IkReal x563=(px*r01);
IkReal x564=((2.0)*cj1);
IkReal x565=(cj1*py);
IkReal x566=((0.03)*r00);
IkReal x567=((0.015)*sj1);
IkReal x568=(cj0*r02);
IkReal x569=(px*sj1);
IkReal x570=(r02*sj0);
IkReal x571=((0.143)*cj3);
IkReal x572=((0.02)*sj1);
IkReal x573=(py*r01);
IkReal x574=(cj1*r02);
IkReal x575=((0.206)*pz);
IkReal x576=((0.010845)*sj3);
IkReal x577=(r02*sj1);
IkReal x578=((0.015)*cj1);
IkReal x579=((0.0003)*cj1);
IkReal x580=((0.0003)*sj1);
IkReal x581=((0.03)*cj1);
IkReal x582=((0.010484)*sj1);
IkReal x583=(px*x568);
IkReal x584=(cj3*x540);
IkReal x585=(cj4*x541);
IkReal x586=(r02*x543);
IkReal x587=(sj4*x541);
IkReal x588=(sj1*x544);
IkReal x589=(cj4*x540);
IkReal x590=(sj1*x542);
IkReal x591=(sj3*x541);
IkReal x592=((0.098)*x540);
IkReal x593=(r02*x544);
IkReal x594=((0.143)*sj3*x540);
evalcond[0]=(((sj1*x545))+(((-1.0)*x562*x584))+((sj1*x560))+x574+(((-1.0)*x562*x591)));
evalcond[1]=((((-1.0)*x545*x547))+(((-1.0)*cj3*x541*x562))+((sj3*x589))+x577+(((-1.0)*x547*x560)));
evalcond[2]=((-0.103)+((sj0*x546))+(((-0.098)*x541))+(((-1.0)*x541*x571))+((cj0*x569))+x556+x555+x594);
evalcond[3]=((((-1.0)*cj0*px*x547))+(((-1.0)*x547*x551))+((x540*x571))+(((-1.0)*x553))+x558+x592+(((0.143)*x591)));
evalcond[4]=((((-1.0)*sj4*x540*x571))+(((-1.0)*pz*x548*x554))+((r00*x565))+((x557*x558))+(((-1.0)*x545*x578))+(((-1.0)*x553*x557))+(((-1.0)*x560*x578))+(((-1.0)*sj4*x592))+((x569*x570))+(((-1.0)*x546*x568))+(((-1.0)*x547*x563))+((r02*x567))+((x553*x554))+(((-0.143)*sj3*x587)));
evalcond[5]=((((-1.0)*x556*x557))+(((-1.0)*px*x547*x570))+((x565*x568))+(((-0.015)*x574))+((x554*x556))+((x554*x555))+(((-0.103)*x554))+((sj4*x594))+(((0.103)*x557))+(((-1.0)*x571*x587))+(((-1.0)*x560*x567))+(((-1.0)*pz*x547*x557))+(((-1.0)*x545*x567))+(((-1.0)*x548*x563))+(((-0.098)*x587))+((r00*x546)));
evalcond[6]=((((-1.0)*x557*x579))+(((-0.206)*x583))+((x560*x575))+((x565*x566))+(((0.03)*x557*x558))+(((-0.03)*x546*x568))+((px*py*x557*x564))+((x554*x579))+(((-0.00206)*r02))+((x545*x575))+(((-0.206)*r02*x551))+((cj1*x542*x545))+((cj1*x552*x583))+(((-1.0)*x563*x581))+(((-1.0)*sj1*x550*x552))+((x543*x577))+(((-1.0)*x542*x547*x560))+(((0.02)*x568*x569))+(((-1.0)*r01*x546*x552))+(((0.010934)*x577))+((x550*x551*x564))+(((-1.0)*x544*x545*x547))+(((-0.02)*x558*x560))+(((-1.0)*x544*x547*x560))+(((0.02)*x546*x570))+(((-0.03)*x554*x558))+((x551*x552*x574))+(((-1.0)*x560*x561))+((x549*x573))+(((-1.0)*x543*x545*x547))+((x549*x559))+((x549*x550))+(((-0.030053)*cj3*x585))+(((-1.0)*x545*x561))+((x576*x589))+(((-1.0)*x548*x593))+((x542*x577))+(((-0.02)*x545*x558))+(((0.03)*x569*x570))+(((-0.028028)*x585))+((cj1*x543*x560)));
evalcond[7]=((((-0.00309)*x557))+(((-0.030053)*cj4*x584))+(((-1.0)*x554*x580))+(((-0.02)*r01*x546))+(((-2.0)*px*x546*x557))+(((0.00309)*x554))+(((-1.0)*x543*x548*x560))+((r02*x549*x551))+((px*x570*x581))+(((-2.0)*sj0*x546*x550))+(((-1.0)*x560*x582))+((sj1*x543*x545))+((x545*x588))+(((-0.03)*x565*x568))+(((-1.0)*cj1*x550*x552))+((x560*x588))+((x543*x574))+(((-1.0)*r01*x552*x565))+(((-0.02)*r02*x558))+(((-1.0)*x546*x566))+(((0.00206)*x560))+((x557*x580))+(((-1.0)*x542*x545*x548))+(((-0.010284)*x574))+(((-1.0)*x546*x552*x570))+(((-0.03)*x554*x555))+(((-1.0)*x576*x585))+((x560*x590))+(((-1.0)*pz*x549*x560))+(((-1.0)*x545*x582))+(((0.206)*x550))+(((0.206)*x559))+(((0.00206)*x545))+(((-1.0)*pz*x545*x549))+(((-1.0)*x550*x572))+(((-1.0)*x547*x593))+(((-1.0)*x552*x568*x569))+((x549*x583))+(((0.03)*x555*x557))+((x542*x574))+(((0.03)*sj1*x563))+(((-0.028028)*x589))+(((0.206)*x573)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x595=(cj1*sj3);
IkReal x596=(cj0*r00);
IkReal x597=(cj1*cj3);
IkReal x598=(r01*sj0);
IkReal x599=(cj3*sj1);
IkReal x600=(sj1*sj3);
CheckValue<IkReal> x601=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x601.valid){
continue;
}
CheckValue<IkReal> x602 = IKatan2WithCheck(IkReal((((x598*x599))+((x595*x598))+((x595*x596))+((r02*x597))+((x596*x599))+(((-1.0)*r02*x600)))),IkReal(((((-1.0)*x596*x597))+(((-1.0)*x597*x598))+((r02*x595))+((r02*x599))+((x596*x600))+((x598*x600)))),IKFAST_ATAN2_MAGTHRESH);
if(!x602.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x601.value)))+(x602.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x603=IKsin(j2);
IkReal x604=IKcos(j2);
IkReal x605=py*py;
IkReal x606=px*px;
IkReal x607=pz*pz;
IkReal x608=(r01*sj0);
IkReal x609=(py*sj1);
IkReal x610=((1.0)*cj1);
IkReal x611=((1.0)*sj1);
IkReal x612=((0.02)*cj1);
IkReal x613=(px*r00);
IkReal x614=(py*sj0);
IkReal x615=((2.0)*pz);
IkReal x616=((0.01)*cj1);
IkReal x617=(r00*sj0);
IkReal x618=(cj1*pz);
IkReal x619=((0.01)*sj1);
IkReal x620=(cj0*r01);
IkReal x621=(pz*sj1);
IkReal x622=(pz*r02);
IkReal x623=(cj0*r00);
IkReal x624=((0.010734)*cj1);
IkReal x625=((1.0)*cj4);
IkReal x626=(px*r01);
IkReal x627=((2.0)*cj1);
IkReal x628=(cj1*py);
IkReal x629=((0.03)*r00);
IkReal x630=((0.015)*sj1);
IkReal x631=(cj0*r02);
IkReal x632=(px*sj1);
IkReal x633=(r02*sj0);
IkReal x634=((0.143)*cj3);
IkReal x635=((0.02)*sj1);
IkReal x636=(py*r01);
IkReal x637=(cj1*r02);
IkReal x638=((0.206)*pz);
IkReal x639=((0.010845)*sj3);
IkReal x640=(r02*sj1);
IkReal x641=((0.015)*cj1);
IkReal x642=((0.0003)*cj1);
IkReal x643=((0.0003)*sj1);
IkReal x644=((0.03)*cj1);
IkReal x645=((0.010484)*sj1);
IkReal x646=(px*x631);
IkReal x647=(cj3*x603);
IkReal x648=(cj4*x604);
IkReal x649=(r02*x606);
IkReal x650=(sj4*x604);
IkReal x651=(sj1*x607);
IkReal x652=(cj4*x603);
IkReal x653=(sj1*x605);
IkReal x654=(sj3*x604);
IkReal x655=((0.098)*x603);
IkReal x656=(r02*x607);
IkReal x657=((0.143)*sj3*x603);
evalcond[0]=(((sj1*x608))+(((-1.0)*x625*x654))+(((-1.0)*x625*x647))+((sj1*x623))+x637);
evalcond[1]=(((sj3*x652))+(((-1.0)*x610*x623))+(((-1.0)*cj3*x604*x625))+x640+(((-1.0)*x608*x610)));
evalcond[2]=((-0.103)+(((-1.0)*x604*x634))+((sj0*x609))+(((-0.098)*x604))+((cj0*x632))+x657+x618+x619);
evalcond[3]=(((x603*x634))+(((-1.0)*x610*x614))+(((-1.0)*cj0*px*x610))+(((-1.0)*x616))+x655+x621+(((0.143)*x654)));
evalcond[4]=(((r02*x630))+(((-1.0)*sj4*x655))+(((-1.0)*x608*x641))+(((-1.0)*x609*x631))+((x616*x617))+(((-1.0)*x610*x626))+(((-0.143)*sj3*x650))+((r00*x628))+(((-1.0)*sj4*x603*x634))+((x632*x633))+(((-1.0)*x616*x620))+(((-1.0)*x623*x641))+(((-1.0)*pz*x611*x617))+((x620*x621)));
evalcond[5]=(((r00*x609))+((sj4*x657))+(((-1.0)*pz*x610*x620))+(((-0.015)*x637))+((x628*x631))+(((-0.103)*x617))+(((-1.0)*x623*x630))+(((0.103)*x620))+(((-1.0)*px*x610*x633))+(((-1.0)*x611*x626))+((x617*x618))+((x617*x619))+(((-0.098)*x650))+(((-1.0)*x619*x620))+(((-1.0)*x634*x650))+(((-1.0)*x608*x630)));
evalcond[6]=(((cj1*x615*x646))+(((0.03)*x620*x621))+(((-0.03)*x617*x621))+(((-0.030053)*cj3*x648))+(((0.010934)*x640))+(((-0.02)*x608*x621))+((x605*x640))+(((0.03)*x632*x633))+((x628*x629))+(((-0.00206)*r02))+(((-1.0)*x626*x644))+((x639*x652))+((x617*x642))+(((-1.0)*x623*x624))+((cj1*x605*x608))+(((-1.0)*sj1*x613*x615))+((x613*x614*x627))+(((0.02)*x609*x633))+(((-1.0)*x607*x610*x623))+((x612*x613))+(((-1.0)*x611*x656))+(((-1.0)*x607*x608*x610))+((x612*x622))+((cj1*x606*x623))+((x612*x636))+((px*py*x620*x627))+((x614*x615*x637))+(((-0.206)*x646))+((x608*x638))+(((0.02)*x631*x632))+(((-1.0)*r01*x609*x615))+(((-1.0)*x606*x608*x610))+(((-1.0)*x605*x610*x623))+(((-0.028028)*x648))+((x606*x640))+(((-1.0)*x620*x642))+(((-0.206)*r02*x614))+((x623*x638))+(((-0.03)*x609*x631))+(((-0.02)*x621*x623))+(((-1.0)*x608*x624)));
evalcond[7]=((((-1.0)*x617*x643))+(((-0.010284)*x637))+(((-1.0)*x608*x645))+(((-0.00309)*x620))+(((-1.0)*cj1*x613*x615))+(((-1.0)*x605*x608*x611))+(((0.00206)*x623))+(((0.206)*x622))+((sj1*x606*x608))+((x608*x651))+(((0.206)*x636))+(((-1.0)*x639*x648))+((x623*x651))+((x623*x653))+(((-0.02)*r01*x609))+(((-1.0)*x610*x656))+(((-1.0)*x606*x611*x623))+(((-0.030053)*cj4*x647))+(((-0.028028)*x652))+(((-2.0)*sj0*x609*x613))+(((-1.0)*pz*x612*x623))+(((0.00309)*x617))+((x605*x637))+(((-1.0)*x609*x615*x633))+((x620*x643))+(((0.03)*sj1*x626))+(((0.00206)*x608))+(((-1.0)*pz*x608*x612))+(((0.03)*x618*x620))+(((-0.03)*x628*x631))+(((-1.0)*x609*x629))+((r02*x612*x614))+(((-1.0)*x615*x631*x632))+((px*x633*x644))+(((-1.0)*x623*x645))+(((-2.0)*px*x609*x620))+(((-0.02)*r02*x621))+(((-0.03)*x617*x618))+(((0.206)*x613))+(((-1.0)*r01*x615*x628))+((x612*x646))+((x606*x637))+(((-1.0)*x613*x635)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x658=((51.5)*r02);
IkReal x659=((51.5)*sj1);
IkReal x660=(cj0*r00);
IkReal x661=((500.0)*px);
IkReal x662=(r01*sj0);
IkReal x663=((500.0)*pz);
IkReal x664=((51.5)*cj1);
IkReal x665=((500.0)*py);
CheckValue<IkReal> x666=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x666.valid){
continue;
}
CheckValue<IkReal> x667 = IKatan2WithCheck(IkReal((((r01*x665))+((r00*x661))+(((-1.0)*x659*x662))+(((-1.0)*x659*x660))+(((-1.0)*cj1*x658))+((r02*x663))+(((-7.5)*cj0*r01))+(((7.5)*r00*sj0))+(((5.0)*x662))+(((5.0)*x660)))),IkReal(((((-1.0)*x662*x663))+((r02*sj0*x665))+(((-1.0)*sj1*x658))+((x662*x664))+(((5.0)*r02))+(((-71.5)*cj4))+(((-1.0)*x660*x663))+((x660*x664))+((cj0*r02*x661)))),IKFAST_ATAN2_MAGTHRESH);
if(!x667.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x666.value)))+(x667.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x668=IKcos(j3);
IkReal x669=pz*pz;
IkReal x670=py*py;
IkReal x671=px*px;
IkReal x672=(cj0*r00);
IkReal x673=(cj0*r02);
IkReal x674=((1.0)*px);
IkReal x675=((0.00206)*sj1);
IkReal x676=((0.103)*sj1);
IkReal x677=(py*sj0);
IkReal x678=(cj0*r01);
IkReal x679=((0.206)*cj1);
IkReal x680=(r00*sj0);
IkReal x681=((0.03)*py);
IkReal x682=(cj1*r02);
IkReal x683=(r01*sj0);
IkReal x684=(px*r01);
IkReal x685=((0.206)*sj1);
IkReal x686=((1.0)*r02);
IkReal x687=((0.03)*px);
IkReal x688=(pz*r02);
IkReal x689=((0.098)*cj4);
IkReal x690=((2.0)*py);
IkReal x691=(py*r00);
IkReal x692=((0.103)*cj1);
IkReal x693=(cj0*px);
IkReal x694=((0.00309)*sj1);
IkReal x695=(px*sj0);
IkReal x696=((0.028028)*x668);
IkReal x697=((1.0)*x669);
IkReal x698=((1.0)*x671);
evalcond[0]=(((r02*x676))+(((-1.0)*x672*x692))+((pz*x672))+(((-1.0)*x683*x692))+(((-1.0)*x677*x686))+(((-0.01)*r02))+(((-1.0)*x673*x674))+(((0.143)*cj4))+((x668*x689))+((pz*x683)));
evalcond[1]=((((-0.015)*x680))+((x672*x676))+(((-0.01)*x683))+(((0.015)*x678))+(((0.103)*x682))+((x676*x683))+(((-0.01)*x672))+(((-1.0)*py*r01))+(((-1.0)*pz*x686))+(((-1.0)*r00*x674))+((x689*(IKsin(j3)))));
evalcond[2]=((0.019119)+(((-1.0)*sj0*x687))+((pz*x679))+((x677*x685))+(((-0.02)*x677))+x675+x696+(((-1.0)*x670))+((cj0*x681))+(((-1.0)*x697))+(((-1.0)*x698))+((x685*x693))+(((-0.02)*x693)));
evalcond[3]=(((x669*x680))+((pz*x673*x690))+((pz*x678*x679))+(((0.010484)*x680))+(((-2.0)*x677*x684))+(((0.00309)*x682))+((px*x672*x690))+(((-0.010484)*x678))+(((0.02)*x691))+(((-1.0)*sj4*x696))+((x670*x678))+(((-1.0)*x675*x680))+((r02*x679*x695))+(((-0.02)*x684))+((x672*x694))+(((-1.0)*r01*x681))+(((-1.0)*r00*x687))+(((-1.0)*x685*x691))+(((-0.0003)*x683))+(((-1.0)*pz*x679*x680))+(((-0.03)*x688))+((x670*x680))+(((-0.0003)*x672))+((x675*x678))+((x684*x685))+(((-1.0)*x678*x698))+(((-1.0)*x678*x697))+(((-0.030053)*sj4))+(((-1.0)*x680*x698))+(((-2.0)*x688*x695))+(((-1.0)*py*x673*x679))+((x683*x694)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[2];
j2eval[0]=cj4;
j2eval[1]=IKsign(cj4);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x699=(cj3*cj4);
j2eval[0]=((((-1.45918367346939)*cj4))+(((-1.0)*x699)));
j2eval[1]=IKsign(((((-98.0)*x699))+(((-143.0)*cj4))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=cj4;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j2eval[0]=((-1.07224917939204)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-30053.0)+(((-28028.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x700=(cj0*px);
IkReal x701=((98000.0)*sj1);
IkReal x702=(py*sj0);
IkReal x703=((98000.0)*cj1);
IkReal x704=((143000.0)*sj3);
IkReal x705=((1430.0)*cj1);
IkReal x706=((1430.0)*sj1);
IkReal x707=((143000.0)*cj1*cj3);
IkReal x708=((143000.0)*cj3*sj1);
CheckValue<IkReal> x709=IKPowWithIntegerCheck(IKsign(((-30053.0)+(((-28028.0)*cj3)))),-1);
if(!x709.valid){
continue;
}
CheckValue<IkReal> x710 = IKatan2WithCheck(IkReal(((((-1.0)*x702*x703))+(((-1.0)*x702*x707))+((sj1*x702*x704))+((sj1*x700*x704))+(((-1.0)*cj3*x705))+((sj3*x706))+(((-980.0)*cj1))+((cj1*pz*x704))+(((-14729.0)*sj3))+((pz*x708))+((pz*x701))+(((-1.0)*x700*x703))+(((-1.0)*x700*x707)))),IkReal(((10094.0)+(((-1.0)*pz*x707))+(((-1.0)*pz*x703))+(((14729.0)*cj3))+(((-1.0)*x702*x708))+(((-980.0)*sj1))+(((-1.0)*cj3*x706))+((pz*sj1*x704))+(((-1.0)*cj1*x700*x704))+(((-1.0)*sj3*x705))+(((-1.0)*x701*x702))+(((-1.0)*x700*x708))+(((-1.0)*x700*x701))+(((-1.0)*cj1*x702*x704)))),IKFAST_ATAN2_MAGTHRESH);
if(!x710.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x709.value)))+(x710.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x711=IKcos(j2);
IkReal x712=IKsin(j2);
IkReal x713=(px*sj1);
IkReal x714=(r00*sj0);
IkReal x715=(py*sj1);
IkReal x716=(cj1*r02);
IkReal x717=((1.0)*px);
IkReal x718=((0.143)*cj3);
IkReal x719=((0.01)*cj1);
IkReal x720=(cj0*r01);
IkReal x721=(cj1*pz);
IkReal x722=((0.01)*sj1);
IkReal x723=((0.015)*cj1);
IkReal x724=(cj0*r00);
IkReal x725=(pz*sj1);
IkReal x726=(r01*sj0);
IkReal x727=((0.015)*sj1);
IkReal x728=(cj1*py);
IkReal x729=((0.143)*sj3);
IkReal x730=((0.098)*x712);
IkReal x731=((0.098)*x711);
IkReal x732=(x712*x718);
IkReal x733=(x711*x729);
IkReal x734=(x712*x729);
IkReal x735=(x711*x718);
IkReal x736=(x735+x731);
IkReal x737=(x733+x732+x730);
evalcond[0]=((-0.103)+((cj0*x713))+(((-1.0)*x736))+((sj0*x715))+x734+x721+x722);
evalcond[1]=((((-1.0)*sj0*x728))+(((-1.0)*x719))+(((-1.0)*cj0*cj1*x717))+x737+x725);
evalcond[2]=(((x714*x719))+((x720*x725))+(((-1.0)*x723*x724))+(((-1.0)*x723*x726))+((r02*sj0*x713))+((r00*x728))+(((-1.0)*x737))+(((-1.0)*x714*x725))+((r02*x727))+(((-1.0)*cj0*r02*x715))+(((-1.0)*x719*x720))+(((-1.0)*cj1*r01*x717)));
evalcond[3]=((((-0.015)*x716))+(((0.103)*x720))+(((-1.0)*x724*x727))+((r00*x715))+(((-1.0)*x720*x721))+((cj0*py*x716))+(((-0.103)*x714))+(((-1.0)*r01*x713))+(((-1.0)*x736))+(((-1.0)*x720*x722))+(((-1.0)*x726*x727))+x734+(((-1.0)*sj0*x716*x717))+((x714*x721))+((x714*x722)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j2eval[0]=((-1.07224917939204)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-30053.0)+(((-28028.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x738=(cj0*px);
IkReal x739=((98000.0)*sj1);
IkReal x740=(py*sj0);
IkReal x741=((98000.0)*cj1);
IkReal x742=((143000.0)*sj3);
IkReal x743=((1430.0)*cj1);
IkReal x744=((1430.0)*sj1);
IkReal x745=((143000.0)*cj1*cj3);
IkReal x746=((143000.0)*cj3*sj1);
CheckValue<IkReal> x747=IKPowWithIntegerCheck(IKsign(((-30053.0)+(((-28028.0)*cj3)))),-1);
if(!x747.valid){
continue;
}
CheckValue<IkReal> x748 = IKatan2WithCheck(IkReal(((((-1.0)*cj3*x743))+((sj1*x740*x742))+((cj1*pz*x742))+(((-1.0)*x738*x741))+(((-1.0)*x738*x745))+((sj3*x744))+(((-980.0)*cj1))+(((-1.0)*x740*x745))+(((-1.0)*x740*x741))+((pz*x739))+((sj1*x738*x742))+(((-14729.0)*sj3))+((pz*x746)))),IkReal(((10094.0)+(((-1.0)*cj3*x744))+(((14729.0)*cj3))+(((-1.0)*cj1*x738*x742))+(((-980.0)*sj1))+(((-1.0)*x738*x746))+(((-1.0)*pz*x741))+(((-1.0)*pz*x745))+(((-1.0)*x740*x746))+(((-1.0)*cj1*x740*x742))+(((-1.0)*x739*x740))+(((-1.0)*x738*x739))+((pz*sj1*x742))+(((-1.0)*sj3*x743)))),IKFAST_ATAN2_MAGTHRESH);
if(!x748.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x747.value)))+(x748.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x749=IKcos(j2);
IkReal x750=IKsin(j2);
IkReal x751=(px*sj1);
IkReal x752=(r00*sj0);
IkReal x753=(py*sj1);
IkReal x754=(cj1*r02);
IkReal x755=((1.0)*px);
IkReal x756=((0.143)*cj3);
IkReal x757=((0.01)*cj1);
IkReal x758=(cj0*r01);
IkReal x759=(cj1*pz);
IkReal x760=((0.01)*sj1);
IkReal x761=((0.015)*cj1);
IkReal x762=(cj0*r00);
IkReal x763=(pz*sj1);
IkReal x764=(r01*sj0);
IkReal x765=((0.015)*sj1);
IkReal x766=(cj1*py);
IkReal x767=((0.143)*sj3);
IkReal x768=((0.098)*x750);
IkReal x769=((0.098)*x749);
IkReal x770=(x750*x756);
IkReal x771=(x749*x767);
IkReal x772=(x749*x756);
IkReal x773=(x750*x767);
IkReal x774=(x772+x769);
IkReal x775=(x771+x770+x768);
evalcond[0]=((-0.103)+((sj0*x753))+((cj0*x751))+x759+x773+x760+(((-1.0)*x774)));
evalcond[1]=((((-1.0)*sj0*x766))+x775+x763+(((-1.0)*x757))+(((-1.0)*cj0*cj1*x755)));
evalcond[2]=(((x752*x757))+(((-1.0)*x752*x763))+((x758*x763))+((r02*sj0*x751))+(((-1.0)*cj1*r01*x755))+((r02*x765))+x775+(((-1.0)*x757*x758))+((r00*x766))+(((-1.0)*x761*x762))+(((-1.0)*x761*x764))+(((-1.0)*cj0*r02*x753)));
evalcond[3]=((((-1.0)*x758*x760))+((cj0*py*x754))+(((-1.0)*x762*x765))+((x752*x759))+(((0.103)*x758))+(((-0.015)*x754))+(((-1.0)*x764*x765))+((x752*x760))+(((-1.0)*sj0*x754*x755))+((r00*x753))+x774+(((-1.0)*x758*x759))+(((-1.0)*x773))+(((-0.103)*x752))+(((-1.0)*r01*x751)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x776=((4.149377593361)*cj1);
IkReal x777=(cj0*px);
IkReal x778=(py*sj0);
IkReal x779=((4.149377593361)*sj1);
if( IKabs((((x776*x778))+((x776*x777))+(((0.04149377593361)*cj1))+(((-1.0)*pz*x779)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.427385892116183)+((pz*x776))+((x777*x779))+(((0.04149377593361)*sj1))+((x778*x779)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x776*x778))+((x776*x777))+(((0.04149377593361)*cj1))+(((-1.0)*pz*x779))))+IKsqr(((-0.427385892116183)+((pz*x776))+((x777*x779))+(((0.04149377593361)*sj1))+((x778*x779))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x776*x778))+((x776*x777))+(((0.04149377593361)*cj1))+(((-1.0)*pz*x779))), ((-0.427385892116183)+((pz*x776))+((x777*x779))+(((0.04149377593361)*sj1))+((x778*x779))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x780=IKcos(j2);
IkReal x781=IKsin(j2);
IkReal x782=py*py;
IkReal x783=px*px;
IkReal x784=pz*pz;
IkReal x785=(r01*sj0);
IkReal x786=(py*sj1);
IkReal x787=((1.0)*cj1);
IkReal x788=((1.0)*sj1);
IkReal x789=((0.02)*cj1);
IkReal x790=(px*r00);
IkReal x791=(py*sj0);
IkReal x792=((2.0)*pz);
IkReal x793=((0.01)*cj1);
IkReal x794=(r00*sj0);
IkReal x795=(cj1*pz);
IkReal x796=((0.01)*sj1);
IkReal x797=(cj0*r01);
IkReal x798=(pz*sj1);
IkReal x799=(pz*r02);
IkReal x800=(px*r01);
IkReal x801=((2.0)*cj1);
IkReal x802=(cj0*r00);
IkReal x803=(cj1*py);
IkReal x804=((0.03)*r00);
IkReal x805=((0.015)*sj1);
IkReal x806=(r02*sj0);
IkReal x807=(px*sj1);
IkReal x808=((0.02)*sj1);
IkReal x809=(cj0*r02);
IkReal x810=((0.010734)*cj1);
IkReal x811=(py*r01);
IkReal x812=(cj1*r02);
IkReal x813=((0.206)*pz);
IkReal x814=(r02*sj1);
IkReal x815=((0.015)*cj1);
IkReal x816=((0.0003)*cj1);
IkReal x817=((0.0003)*sj1);
IkReal x818=((0.03)*cj1);
IkReal x819=((0.010484)*sj1);
IkReal x820=(cj4*x781);
IkReal x821=(px*x809);
IkReal x822=(cj4*x780);
IkReal x823=(r02*x783);
IkReal x824=((0.241)*x780);
IkReal x825=((0.241)*x781);
IkReal x826=(sj1*x784);
IkReal x827=(sj1*x782);
IkReal x828=(r02*x784);
evalcond[0]=(((sj1*x785))+(((-1.0)*x820))+((sj1*x802))+x812);
evalcond[1]=((((-1.0)*x787*x802))+(((-1.0)*x822))+x814+(((-1.0)*x785*x787)));
evalcond[2]=((-0.103)+(((-1.0)*x824))+((sj0*x786))+((cj0*x807))+x795+x796);
evalcond[3]=((((-1.0)*x793))+(((-1.0)*x787*x791))+x798+x825+(((-1.0)*cj0*px*x787)));
evalcond[4]=(((x806*x807))+(((-1.0)*x787*x800))+(((-1.0)*x802*x815))+((x793*x794))+(((-1.0)*x793*x797))+(((-1.0)*sj4*x825))+(((-1.0)*x785*x815))+((r02*x805))+(((-1.0)*pz*x788*x794))+((r00*x803))+(((-1.0)*x786*x809))+((x797*x798)));
evalcond[5]=(((r00*x786))+(((-1.0)*x785*x805))+(((-1.0)*px*x787*x806))+(((-1.0)*x796*x797))+(((-0.015)*x812))+(((-1.0)*sj4*x824))+((x803*x809))+(((-1.0)*x788*x800))+(((-1.0)*pz*x787*x797))+(((-0.103)*x794))+(((0.103)*x797))+((x794*x796))+((x794*x795))+(((-1.0)*x802*x805)));
evalcond[6]=(((cj1*x783*x802))+((cj1*x782*x785))+(((0.03)*x806*x807))+(((-1.0)*x784*x785*x787))+((x794*x816))+(((-1.0)*x788*x828))+(((-0.00206)*r02))+(((-1.0)*r01*x786*x792))+(((-1.0)*x802*x810))+(((-0.206)*x821))+(((-1.0)*x783*x785*x787))+((x790*x791*x801))+((x802*x813))+((x803*x804))+(((-0.02)*x798*x802))+((x783*x814))+(((0.03)*x797*x798))+(((-0.03)*x794*x798))+(((0.02)*x807*x809))+(((-1.0)*x785*x810))+((px*py*x797*x801))+((x782*x814))+(((-0.206)*r02*x791))+(((0.02)*x786*x806))+((x785*x813))+(((-1.0)*x784*x787*x802))+((cj1*x792*x821))+(((-0.03)*x786*x809))+(((0.010934)*x814))+(((-0.02)*x785*x798))+((x789*x811))+(((-1.0)*x800*x818))+((x789*x799))+((x789*x790))+(((-1.0)*x797*x816))+(((-1.0)*x782*x787*x802))+(((-0.058081)*x822))+((x791*x792*x812))+(((-1.0)*sj1*x790*x792)));
evalcond[7]=(((sj1*x783*x785))+(((0.206)*x811))+((x797*x817))+(((0.03)*sj1*x800))+(((-2.0)*px*x786*x797))+(((-0.03)*x803*x809))+(((-1.0)*x786*x804))+(((-0.010284)*x812))+(((-1.0)*x794*x817))+(((0.00206)*x785))+(((0.00206)*x802))+(((0.00309)*x794))+(((-1.0)*pz*x785*x789))+(((-0.00309)*x797))+((px*x806*x818))+(((-1.0)*x790*x808))+(((-1.0)*x802*x819))+((x802*x827))+((x802*x826))+(((-1.0)*r01*x792*x803))+(((-0.02)*r02*x798))+(((-2.0)*sj0*x786*x790))+((x783*x812))+(((-1.0)*x792*x807*x809))+(((-0.03)*x794*x795))+((r02*x789*x791))+(((-1.0)*x785*x819))+(((-1.0)*x787*x828))+(((-1.0)*x782*x785*x788))+((x782*x812))+(((-1.0)*cj1*x790*x792))+((x785*x826))+(((-0.02)*r01*x786))+(((-1.0)*pz*x789*x802))+((x789*x821))+(((-1.0)*x783*x788*x802))+(((-1.0)*x786*x792*x806))+(((0.206)*x799))+(((0.206)*x790))+(((-0.058081)*x820))+(((0.03)*x795*x797)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x829=((22.2222222222222)*cj1);
IkReal x830=(py*sj0);
IkReal x831=((22.2222222222222)*sj1);
IkReal x832=(cj0*px);
if( IKabs((((pz*x831))+(((-0.222222222222222)*cj1))+(((-1.0)*x829*x830))+(((-1.0)*x829*x832)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.28888888888889)+(((-1.0)*pz*x829))+(((-1.0)*x830*x831))+(((-0.222222222222222)*sj1))+(((-1.0)*x831*x832)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((pz*x831))+(((-0.222222222222222)*cj1))+(((-1.0)*x829*x830))+(((-1.0)*x829*x832))))+IKsqr(((2.28888888888889)+(((-1.0)*pz*x829))+(((-1.0)*x830*x831))+(((-0.222222222222222)*sj1))+(((-1.0)*x831*x832))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((pz*x831))+(((-0.222222222222222)*cj1))+(((-1.0)*x829*x830))+(((-1.0)*x829*x832))), ((2.28888888888889)+(((-1.0)*pz*x829))+(((-1.0)*x830*x831))+(((-0.222222222222222)*sj1))+(((-1.0)*x831*x832))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x833=IKcos(j2);
IkReal x834=IKsin(j2);
IkReal x835=py*py;
IkReal x836=px*px;
IkReal x837=pz*pz;
IkReal x838=(r01*sj0);
IkReal x839=(py*sj1);
IkReal x840=((1.0)*cj1);
IkReal x841=((1.0)*sj1);
IkReal x842=((0.02)*cj1);
IkReal x843=(px*r00);
IkReal x844=(py*sj0);
IkReal x845=((0.002025)*cj4);
IkReal x846=((0.01)*cj1);
IkReal x847=(pz*r01);
IkReal x848=(r00*sj0);
IkReal x849=(cj1*pz);
IkReal x850=((0.01)*sj1);
IkReal x851=(cj0*r01);
IkReal x852=(pz*sj1);
IkReal x853=(pz*r02);
IkReal x854=(cj0*sj1);
IkReal x855=((0.03)*cj1);
IkReal x856=(px*r01);
IkReal x857=((2.0)*cj1);
IkReal x858=(cj0*r00);
IkReal x859=(py*r00);
IkReal x860=(cj1*r02);
IkReal x861=(r02*sj0);
IkReal x862=(px*sj1);
IkReal x863=((2.0)*sj0);
IkReal x864=((0.02)*sj1);
IkReal x865=(cj0*py);
IkReal x866=((0.010734)*cj1);
IkReal x867=(py*r01);
IkReal x868=(r02*sj1);
IkReal x869=(cj0*r02);
IkReal x870=((0.206)*pz);
IkReal x871=((0.015)*cj1);
IkReal x872=((0.0003)*cj1);
IkReal x873=((0.0003)*sj1);
IkReal x874=(px*x869);
IkReal x875=((0.045)*x833);
IkReal x876=(sj1*x836);
IkReal x877=((0.045)*x834);
IkReal x878=(r02*x837);
evalcond[0]=(((r00*x854))+((cj4*x834))+x860+((sj1*x838)));
evalcond[1]=(((cj4*x833))+(((-1.0)*x838*x840))+(((-1.0)*x840*x858))+x868);
evalcond[2]=((-0.103)+((px*x854))+x850+x875+x849+((sj0*x839)));
evalcond[3]=((((-1.0)*x840*x844))+(((-1.0)*x846))+(((-1.0)*cj0*px*x840))+x852+(((-1.0)*x877)));
evalcond[4]=((((-1.0)*x846*x851))+((x846*x848))+(((-1.0)*pz*x841*x848))+(((-1.0)*x839*x869))+((x847*x854))+((cj1*x859))+(((-1.0)*x838*x871))+((x861*x862))+((sj4*x877))+(((0.015)*x868))+(((-1.0)*x840*x856))+(((-1.0)*x858*x871)));
evalcond[5]=(((x848*x850))+(((-0.015)*x860))+(((-0.015)*sj1*x838))+(((-1.0)*px*x840*x861))+(((-1.0)*x850*x851))+(((-0.103)*x848))+((x848*x849))+((r00*x839))+(((-0.015)*r00*x854))+(((-1.0)*x841*x856))+((sj4*x875))+(((-1.0)*cj0*x840*x847))+((x860*x865))+(((0.103)*x851)));
evalcond[6]=(((cj1*x835*x838))+((x836*x868))+(((-0.02)*x838*x852))+((x842*x853))+(((-0.206)*x874))+((x848*x872))+((px*py*x851*x857))+((x855*x859))+(((-0.00206)*r02))+((x833*x845))+((x842*x867))+((cj1*x836*x858))+(((-1.0)*x841*x878))+(((0.010934)*x868))+(((-1.0)*x838*x866))+(((2.0)*r02*x844*x849))+(((-0.03)*x848*x852))+((x842*x843))+(((0.02)*x839*x861))+((x858*x870))+((x843*x844*x857))+((x835*x868))+(((-1.0)*x837*x840*x858))+(((-1.0)*x851*x872))+(((-0.02)*x852*x858))+(((-2.0)*x839*x847))+(((-1.0)*x858*x866))+((x838*x870))+(((0.02)*px*r02*x854))+(((-2.0)*x843*x852))+(((0.03)*x847*x854))+(((-1.0)*x855*x856))+(((2.0)*x849*x874))+(((-1.0)*x836*x838*x840))+(((-1.0)*x837*x838*x840))+(((-1.0)*x835*x840*x858))+(((-0.03)*x839*x869))+(((0.03)*x861*x862))+(((-0.206)*r02*x844)));
evalcond[7]=((((-1.0)*x835*x838*x841))+((x836*x860))+(((-0.00309)*x851))+(((-0.03)*x848*x849))+((cj0*x847*x855))+(((-0.010284)*x860))+((px*x855*x861))+(((-1.0)*py*x847*x857))+((r02*x842*x844))+((x842*x874))+(((-0.02)*r01*x839))+(((0.206)*x843))+(((-1.0)*x839*x853*x863))+(((-0.010484)*sj1*x838))+(((-1.0)*x848*x873))+(((-2.0)*x843*x849))+(((-0.02)*r02*x852))+(((0.00206)*x838))+(((-1.0)*r02*x855*x865))+((x851*x873))+(((-2.0)*x852*x874))+((x834*x845))+((x835*x860))+(((-1.0)*pz*x838*x842))+((sj1*x837*x838))+(((0.206)*x867))+(((-1.0)*x843*x864))+((r00*x835*x854))+(((-0.010484)*r00*x854))+((x838*x876))+(((0.206)*x853))+(((-0.03)*r00*x839))+(((0.03)*sj1*x856))+((r00*x837*x854))+(((-1.0)*x836*x841*x858))+(((-1.0)*x840*x878))+(((-2.0)*px*x839*x851))+(((-1.0)*x839*x843*x863))+(((0.00309)*x848))+(((-1.0)*pz*x842*x858))+(((0.00206)*x858)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x892=IKPowWithIntegerCheck(cj4,-1);
if(!x892.valid){
continue;
}
IkReal x879=x892.value;
IkReal x880=(cj1*cj3);
IkReal x881=((10.0)*cj4);
IkReal x882=(cj1*r02);
IkReal x883=((143.0)*sj1);
IkReal x884=(r01*sj0);
IkReal x885=((1000.0)*cj4);
IkReal x886=(pz*sj1);
IkReal x887=(cj0*px);
IkReal x888=(cj0*r00);
IkReal x889=((98.0)*sj1);
IkReal x890=(py*sj0);
IkReal x891=((-0.0102040816326531)*x879);
CheckValue<IkReal> x893=IKPowWithIntegerCheck(sj3,-1);
if(!x893.valid){
continue;
}
if( IKabs((x891*(((((143.0)*x882))+((x883*x884))+((x883*x888))+(((-1.0)*cj1*x885*x887))+(((-1.0)*cj1*x885*x890))+(((-1.0)*cj1*x881))+((x885*x886)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x891*(x893.value)*((((x880*x885*x890))+(((-98.0)*x882))+((x880*x881))+((x880*x885*x887))+(((-1.0)*cj3*x885*x886))+(((-143.0)*r02*x880))+(((-1.0)*cj3*x883*x888))+(((-1.0)*cj3*x883*x884))+(((-1.0)*x888*x889))+(((-1.0)*x884*x889)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x891*(((((143.0)*x882))+((x883*x884))+((x883*x888))+(((-1.0)*cj1*x885*x887))+(((-1.0)*cj1*x885*x890))+(((-1.0)*cj1*x881))+((x885*x886))))))+IKsqr((x891*(x893.value)*((((x880*x885*x890))+(((-98.0)*x882))+((x880*x881))+((x880*x885*x887))+(((-1.0)*cj3*x885*x886))+(((-143.0)*r02*x880))+(((-1.0)*cj3*x883*x888))+(((-1.0)*cj3*x883*x884))+(((-1.0)*x888*x889))+(((-1.0)*x884*x889))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x891*(((((143.0)*x882))+((x883*x884))+((x883*x888))+(((-1.0)*cj1*x885*x887))+(((-1.0)*cj1*x885*x890))+(((-1.0)*cj1*x881))+((x885*x886))))), (x891*(x893.value)*((((x880*x885*x890))+(((-98.0)*x882))+((x880*x881))+((x880*x885*x887))+(((-1.0)*cj3*x885*x886))+(((-143.0)*r02*x880))+(((-1.0)*cj3*x883*x888))+(((-1.0)*cj3*x883*x884))+(((-1.0)*x888*x889))+(((-1.0)*x884*x889))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x894=IKsin(j2);
IkReal x895=IKcos(j2);
IkReal x896=py*py;
IkReal x897=px*px;
IkReal x898=pz*pz;
IkReal x899=(r01*sj0);
IkReal x900=(py*sj1);
IkReal x901=((1.0)*cj1);
IkReal x902=((1.0)*sj1);
IkReal x903=((0.02)*cj1);
IkReal x904=(px*r00);
IkReal x905=(py*sj0);
IkReal x906=((2.0)*pz);
IkReal x907=((0.01)*cj1);
IkReal x908=(r00*sj0);
IkReal x909=(cj1*pz);
IkReal x910=((0.01)*sj1);
IkReal x911=(cj0*r01);
IkReal x912=(pz*sj1);
IkReal x913=(pz*r02);
IkReal x914=(cj0*r00);
IkReal x915=((0.010734)*cj1);
IkReal x916=((1.0)*cj4);
IkReal x917=(px*r01);
IkReal x918=((2.0)*cj1);
IkReal x919=(cj1*py);
IkReal x920=((0.03)*r00);
IkReal x921=((0.015)*sj1);
IkReal x922=(cj0*r02);
IkReal x923=(px*sj1);
IkReal x924=(r02*sj0);
IkReal x925=((0.143)*cj3);
IkReal x926=((0.02)*sj1);
IkReal x927=(py*r01);
IkReal x928=(cj1*r02);
IkReal x929=((0.206)*pz);
IkReal x930=((0.010845)*sj3);
IkReal x931=(r02*sj1);
IkReal x932=((0.015)*cj1);
IkReal x933=((0.0003)*cj1);
IkReal x934=((0.0003)*sj1);
IkReal x935=((0.03)*cj1);
IkReal x936=((0.010484)*sj1);
IkReal x937=(px*x922);
IkReal x938=(cj3*x894);
IkReal x939=(cj4*x895);
IkReal x940=(r02*x897);
IkReal x941=(sj4*x895);
IkReal x942=(sj1*x898);
IkReal x943=(cj4*x894);
IkReal x944=(sj1*x896);
IkReal x945=(sj3*x895);
IkReal x946=((0.098)*x894);
IkReal x947=(r02*x898);
IkReal x948=((0.143)*sj3*x894);
evalcond[0]=(((sj1*x899))+(((-1.0)*x916*x938))+x928+((sj1*x914))+(((-1.0)*x916*x945)));
evalcond[1]=(((sj3*x943))+(((-1.0)*cj3*x895*x916))+x931+(((-1.0)*x899*x901))+(((-1.0)*x901*x914)));
evalcond[2]=((-0.103)+((sj0*x900))+(((-1.0)*x895*x925))+((cj0*x923))+x910+x909+x948+(((-0.098)*x895)));
evalcond[3]=((((-1.0)*x907))+(((-1.0)*cj0*px*x901))+((x894*x925))+(((0.143)*x945))+(((-1.0)*x901*x905))+x912+x946);
evalcond[4]=((((-1.0)*x914*x932))+(((-1.0)*x899*x932))+(((-1.0)*sj4*x946))+((x907*x908))+((x911*x912))+(((-1.0)*x900*x922))+(((-1.0)*sj4*x894*x925))+(((-0.143)*sj3*x941))+((x923*x924))+(((-1.0)*x907*x911))+(((-1.0)*pz*x902*x908))+((r02*x921))+((r00*x919))+(((-1.0)*x901*x917)));
evalcond[5]=(((r00*x900))+(((-1.0)*pz*x901*x911))+((x919*x922))+(((-0.098)*x941))+(((-1.0)*x914*x921))+(((-1.0)*x899*x921))+(((-0.103)*x908))+(((-1.0)*px*x901*x924))+(((-1.0)*x902*x917))+(((0.103)*x911))+(((-1.0)*x910*x911))+((sj4*x948))+(((-1.0)*x925*x941))+((x908*x910))+((x908*x909))+(((-0.015)*x928)));
evalcond[6]=((((-1.0)*x902*x947))+(((-0.02)*x912*x914))+(((0.02)*x922*x923))+(((0.02)*x900*x924))+((x919*x920))+((x905*x906*x928))+((x897*x931))+(((-1.0)*x898*x899*x901))+((x908*x933))+((x903*x904))+((x899*x929))+(((0.010934)*x931))+(((-0.030053)*cj3*x939))+(((-0.00206)*r02))+((cj1*x897*x914))+(((-1.0)*r01*x900*x906))+((x903*x913))+(((-0.028028)*x939))+(((-0.03)*x900*x922))+((x930*x943))+((x903*x927))+((cj1*x906*x937))+(((-0.206)*x937))+(((0.03)*x923*x924))+(((0.03)*x911*x912))+((x896*x931))+((x904*x905*x918))+((x914*x929))+(((-0.206)*r02*x905))+(((-1.0)*x914*x915))+(((-1.0)*x898*x901*x914))+((px*py*x911*x918))+(((-0.02)*x899*x912))+(((-1.0)*x899*x915))+(((-1.0)*x917*x935))+(((-1.0)*sj1*x904*x906))+(((-1.0)*x896*x901*x914))+(((-0.03)*x908*x912))+((cj1*x896*x899))+(((-1.0)*x897*x899*x901))+(((-1.0)*x911*x933)));
evalcond[7]=((((-0.03)*x919*x922))+(((0.206)*x913))+(((-0.030053)*cj4*x938))+(((-0.03)*x908*x909))+((x897*x928))+(((-1.0)*pz*x899*x903))+(((-1.0)*x930*x939))+(((0.03)*sj1*x917))+(((-1.0)*x904*x926))+(((-1.0)*x900*x906*x924))+((x899*x942))+(((-1.0)*x914*x936))+(((-1.0)*x899*x936))+((x911*x934))+((sj1*x897*x899))+(((-1.0)*r01*x906*x919))+(((-1.0)*x906*x922*x923))+(((-1.0)*x901*x947))+((px*x924*x935))+(((-1.0)*cj1*x904*x906))+(((0.03)*x909*x911))+(((-2.0)*sj0*x900*x904))+(((0.00309)*x908))+((x903*x937))+((x896*x928))+(((-1.0)*x896*x899*x902))+(((-2.0)*px*x900*x911))+((r02*x903*x905))+(((-1.0)*x897*x902*x914))+(((-0.02)*r01*x900))+(((-0.028028)*x943))+(((0.00206)*x914))+(((-1.0)*pz*x903*x914))+(((-1.0)*x900*x920))+(((0.206)*x927))+(((-1.0)*x908*x934))+(((0.00206)*x899))+((x914*x944))+((x914*x942))+(((-0.02)*r02*x912))+(((-0.010284)*x928))+(((-0.00309)*x911))+(((0.206)*x904)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x949=((1000.0)*cj4);
IkReal x950=(cj3*sj1);
IkReal x951=(py*sj0);
IkReal x952=(cj1*sj3);
IkReal x953=((103.0)*cj4);
IkReal x954=((10.0)*cj4);
IkReal x955=(cj0*r00);
IkReal x956=((98.0)*sj1);
IkReal x957=(sj1*sj3);
IkReal x958=(cj0*px);
IkReal x959=((143.0)*r02);
IkReal x960=(r01*sj0);
IkReal x961=(cj1*cj3);
CheckValue<IkReal> x962=IKPowWithIntegerCheck(IKsign(((((-98.0)*cj3*cj4))+(((-143.0)*cj4)))),-1);
if(!x962.valid){
continue;
}
CheckValue<IkReal> x963 = IKatan2WithCheck(IkReal((((pz*x949*x952))+((x949*x957*x958))+(((-1.0)*x956*x960))+(((-98.0)*cj1*r02))+(((-1.0)*x959*x961))+(((-1.0)*sj3*x953))+(((-143.0)*x950*x955))+((x949*x951*x957))+(((-143.0)*x950*x960))+(((-1.0)*x955*x956))+((x954*x957)))),IkReal(((((-1.0)*pz*x949*x961))+(((-143.0)*x955*x957))+(((-143.0)*x957*x960))+((cj3*x953))+(((-1.0)*x949*x950*x958))+(((-1.0)*x949*x950*x951))+(((-1.0)*x950*x954))+(((-1.0)*x952*x959)))),IKFAST_ATAN2_MAGTHRESH);
if(!x963.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x962.value)))+(x963.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x964=IKsin(j2);
IkReal x965=IKcos(j2);
IkReal x966=py*py;
IkReal x967=px*px;
IkReal x968=pz*pz;
IkReal x969=(r01*sj0);
IkReal x970=(py*sj1);
IkReal x971=((1.0)*cj1);
IkReal x972=((1.0)*sj1);
IkReal x973=((0.02)*cj1);
IkReal x974=(px*r00);
IkReal x975=(py*sj0);
IkReal x976=((2.0)*pz);
IkReal x977=((0.01)*cj1);
IkReal x978=(r00*sj0);
IkReal x979=(cj1*pz);
IkReal x980=((0.01)*sj1);
IkReal x981=(cj0*r01);
IkReal x982=(pz*sj1);
IkReal x983=(pz*r02);
IkReal x984=(cj0*r00);
IkReal x985=((0.010734)*cj1);
IkReal x986=((1.0)*cj4);
IkReal x987=(px*r01);
IkReal x988=((2.0)*cj1);
IkReal x989=(cj1*py);
IkReal x990=((0.03)*r00);
IkReal x991=((0.015)*sj1);
IkReal x992=(cj0*r02);
IkReal x993=(px*sj1);
IkReal x994=(r02*sj0);
IkReal x995=((0.143)*cj3);
IkReal x996=((0.02)*sj1);
IkReal x997=(py*r01);
IkReal x998=(cj1*r02);
IkReal x999=((0.206)*pz);
IkReal x1000=((0.010845)*sj3);
IkReal x1001=(r02*sj1);
IkReal x1002=((0.015)*cj1);
IkReal x1003=((0.0003)*cj1);
IkReal x1004=((0.0003)*sj1);
IkReal x1005=((0.03)*cj1);
IkReal x1006=((0.010484)*sj1);
IkReal x1007=(px*x992);
IkReal x1008=(cj3*x964);
IkReal x1009=(cj4*x965);
IkReal x1010=(r02*x967);
IkReal x1011=(sj4*x965);
IkReal x1012=(sj1*x968);
IkReal x1013=(cj4*x964);
IkReal x1014=(sj1*x966);
IkReal x1015=(sj3*x965);
IkReal x1016=((0.098)*x964);
IkReal x1017=(r02*x968);
IkReal x1018=((0.143)*sj3*x964);
evalcond[0]=((((-1.0)*x1015*x986))+(((-1.0)*x1008*x986))+((sj1*x984))+((sj1*x969))+x998);
evalcond[1]=(x1001+(((-1.0)*x969*x971))+(((-1.0)*x971*x984))+(((-1.0)*cj3*x965*x986))+((sj3*x1013)));
evalcond[2]=((-0.103)+x1018+(((-0.098)*x965))+((sj0*x970))+(((-1.0)*x965*x995))+((cj0*x993))+x980+x979);
evalcond[3]=((((-1.0)*cj0*px*x971))+x1016+(((0.143)*x1015))+(((-1.0)*x971*x975))+x982+((x964*x995))+(((-1.0)*x977)));
evalcond[4]=(((x981*x982))+((x993*x994))+((x977*x978))+(((-1.0)*sj4*x964*x995))+((r00*x989))+((r02*x991))+(((-1.0)*pz*x972*x978))+(((-1.0)*x971*x987))+(((-1.0)*x970*x992))+(((-1.0)*x977*x981))+(((-1.0)*x1002*x969))+(((-1.0)*x1002*x984))+(((-0.143)*sj3*x1011))+(((-1.0)*sj4*x1016)));
evalcond[5]=(((x978*x979))+(((0.103)*x981))+((x989*x992))+(((-1.0)*px*x971*x994))+(((-0.098)*x1011))+(((-0.015)*x998))+((sj4*x1018))+(((-1.0)*x969*x991))+((r00*x970))+(((-1.0)*pz*x971*x981))+(((-1.0)*x1011*x995))+(((-1.0)*x984*x991))+(((-1.0)*x972*x987))+(((-1.0)*x980*x981))+(((-0.103)*x978))+((x978*x980)));
evalcond[6]=((((-1.0)*r01*x970*x976))+((cj1*x967*x984))+((x974*x975*x988))+(((-1.0)*x1017*x972))+((x989*x990))+(((-1.0)*x966*x971*x984))+((cj1*x1007*x976))+(((-0.03)*x970*x992))+(((-1.0)*x969*x985))+(((-0.00206)*r02))+(((-1.0)*x967*x969*x971))+(((0.03)*x993*x994))+(((0.03)*x981*x982))+((x1000*x1013))+((x1001*x966))+((x1001*x967))+(((-0.206)*x1007))+((x973*x983))+((x975*x976*x998))+(((-1.0)*x1005*x987))+((x973*x974))+(((-0.030053)*cj3*x1009))+(((-0.028028)*x1009))+(((0.010934)*x1001))+(((0.02)*x992*x993))+((x969*x999))+((x1003*x978))+((px*py*x981*x988))+((cj1*x966*x969))+(((-1.0)*x984*x985))+(((-0.02)*x969*x982))+(((-1.0)*x1003*x981))+(((-1.0)*sj1*x974*x976))+(((-0.206)*r02*x975))+((x973*x997))+(((-0.03)*x978*x982))+(((-1.0)*x968*x969*x971))+(((-1.0)*x968*x971*x984))+(((0.02)*x970*x994))+((x984*x999))+(((-0.02)*x982*x984)));
evalcond[7]=(((x1012*x969))+((x966*x998))+(((-1.0)*x976*x992*x993))+(((-0.02)*r02*x982))+(((-1.0)*x1017*x971))+((x1004*x981))+(((-1.0)*cj1*x974*x976))+(((-0.00309)*x981))+(((-0.03)*x989*x992))+(((-1.0)*pz*x973*x984))+(((0.206)*x997))+(((0.00309)*x978))+(((-0.030053)*cj4*x1008))+(((-2.0)*sj0*x970*x974))+((r02*x973*x975))+((x1007*x973))+(((-1.0)*x1004*x978))+(((-1.0)*x1006*x984))+(((-1.0)*x1006*x969))+((x1014*x984))+(((-1.0)*r01*x976*x989))+(((-2.0)*px*x970*x981))+(((-1.0)*x967*x972*x984))+(((-0.010284)*x998))+(((0.00206)*x969))+(((0.206)*x974))+(((-1.0)*pz*x969*x973))+(((-1.0)*x970*x990))+(((0.03)*sj1*x987))+(((0.00206)*x984))+(((0.206)*x983))+(((-1.0)*x1000*x1009))+(((-0.028028)*x1013))+((x1012*x984))+(((-1.0)*x974*x996))+(((-0.02)*r01*x970))+(((-1.0)*x966*x969*x972))+((px*x1005*x994))+(((-1.0)*x970*x976*x994))+((x967*x998))+(((0.03)*x979*x981))+((sj1*x967*x969))+(((-0.03)*x978*x979)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1019=(cj1*sj3);
IkReal x1020=(cj0*r00);
IkReal x1021=(cj1*cj3);
IkReal x1022=(r01*sj0);
IkReal x1023=(cj3*sj1);
IkReal x1024=(sj1*sj3);
CheckValue<IkReal> x1025=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x1025.valid){
continue;
}
CheckValue<IkReal> x1026 = IKatan2WithCheck(IkReal((((x1022*x1023))+((x1019*x1022))+((x1019*x1020))+((x1020*x1023))+((r02*x1021))+(((-1.0)*r02*x1024)))),IkReal((((r02*x1019))+(((-1.0)*x1021*x1022))+((x1022*x1024))+((x1020*x1024))+((r02*x1023))+(((-1.0)*x1020*x1021)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1026.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1025.value)))+(x1026.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x1027=IKsin(j2);
IkReal x1028=IKcos(j2);
IkReal x1029=py*py;
IkReal x1030=px*px;
IkReal x1031=pz*pz;
IkReal x1032=(r01*sj0);
IkReal x1033=(py*sj1);
IkReal x1034=((1.0)*cj1);
IkReal x1035=((1.0)*sj1);
IkReal x1036=((0.02)*cj1);
IkReal x1037=(px*r00);
IkReal x1038=(py*sj0);
IkReal x1039=((2.0)*pz);
IkReal x1040=((0.01)*cj1);
IkReal x1041=(r00*sj0);
IkReal x1042=(cj1*pz);
IkReal x1043=((0.01)*sj1);
IkReal x1044=(cj0*r01);
IkReal x1045=(pz*sj1);
IkReal x1046=(pz*r02);
IkReal x1047=(cj0*r00);
IkReal x1048=((0.010734)*cj1);
IkReal x1049=((1.0)*cj4);
IkReal x1050=(px*r01);
IkReal x1051=((2.0)*cj1);
IkReal x1052=(cj1*py);
IkReal x1053=((0.03)*r00);
IkReal x1054=((0.015)*sj1);
IkReal x1055=(cj0*r02);
IkReal x1056=(px*sj1);
IkReal x1057=(r02*sj0);
IkReal x1058=((0.143)*cj3);
IkReal x1059=((0.02)*sj1);
IkReal x1060=(py*r01);
IkReal x1061=(cj1*r02);
IkReal x1062=((0.206)*pz);
IkReal x1063=((0.010845)*sj3);
IkReal x1064=(r02*sj1);
IkReal x1065=((0.015)*cj1);
IkReal x1066=((0.0003)*cj1);
IkReal x1067=((0.0003)*sj1);
IkReal x1068=((0.03)*cj1);
IkReal x1069=((0.010484)*sj1);
IkReal x1070=(px*x1055);
IkReal x1071=(cj3*x1027);
IkReal x1072=(cj4*x1028);
IkReal x1073=(r02*x1030);
IkReal x1074=(sj4*x1028);
IkReal x1075=(sj1*x1031);
IkReal x1076=(cj4*x1027);
IkReal x1077=(sj1*x1029);
IkReal x1078=(sj3*x1028);
IkReal x1079=((0.098)*x1027);
IkReal x1080=(r02*x1031);
IkReal x1081=((0.143)*sj3*x1027);
evalcond[0]=(x1061+((sj1*x1032))+((sj1*x1047))+(((-1.0)*x1049*x1078))+(((-1.0)*x1049*x1071)));
evalcond[1]=(x1064+(((-1.0)*x1032*x1034))+((sj3*x1076))+(((-1.0)*cj3*x1028*x1049))+(((-1.0)*x1034*x1047)));
evalcond[2]=((-0.103)+x1043+x1042+x1081+((cj0*x1056))+((sj0*x1033))+(((-1.0)*x1028*x1058))+(((-0.098)*x1028)));
evalcond[3]=((((0.143)*x1078))+x1045+x1079+(((-1.0)*x1034*x1038))+(((-1.0)*cj0*px*x1034))+((x1027*x1058))+(((-1.0)*x1040)));
evalcond[4]=((((-1.0)*x1047*x1065))+(((-1.0)*x1033*x1055))+((r02*x1054))+((x1040*x1041))+((x1056*x1057))+((r00*x1052))+(((-0.143)*sj3*x1074))+(((-1.0)*sj4*x1079))+(((-1.0)*x1040*x1044))+(((-1.0)*x1034*x1050))+(((-1.0)*pz*x1035*x1041))+(((-1.0)*x1032*x1065))+(((-1.0)*sj4*x1027*x1058))+((x1044*x1045)));
evalcond[5]=(((r00*x1033))+(((-0.015)*x1061))+(((0.103)*x1044))+(((-0.098)*x1074))+((x1041*x1042))+((x1041*x1043))+((x1052*x1055))+(((-1.0)*px*x1034*x1057))+(((-1.0)*x1043*x1044))+(((-1.0)*x1058*x1074))+(((-1.0)*pz*x1034*x1044))+((sj4*x1081))+(((-1.0)*x1035*x1050))+(((-0.103)*x1041))+(((-1.0)*x1047*x1054))+(((-1.0)*x1032*x1054)));
evalcond[6]=((((0.02)*x1055*x1056))+((x1038*x1039*x1061))+(((-1.0)*x1031*x1034*x1047))+(((-1.0)*x1031*x1032*x1034))+(((-1.0)*x1032*x1048))+((x1036*x1037))+(((-0.02)*x1032*x1045))+(((-0.02)*x1045*x1047))+(((-1.0)*r01*x1033*x1039))+(((-0.206)*x1070))+(((0.03)*x1044*x1045))+((cj1*x1029*x1032))+(((-1.0)*sj1*x1037*x1039))+(((-0.00206)*r02))+(((0.010934)*x1064))+(((-1.0)*x1044*x1066))+((cj1*x1039*x1070))+((x1030*x1064))+(((-0.028028)*x1072))+((x1052*x1053))+(((0.03)*x1056*x1057))+((x1041*x1066))+((x1063*x1076))+((x1032*x1062))+(((-1.0)*x1029*x1034*x1047))+((x1036*x1046))+(((-0.03)*x1041*x1045))+((cj1*x1030*x1047))+((x1037*x1038*x1051))+(((0.02)*x1033*x1057))+((x1036*x1060))+(((-1.0)*x1030*x1032*x1034))+(((-0.030053)*cj3*x1072))+((x1047*x1062))+((px*py*x1044*x1051))+((x1029*x1064))+(((-1.0)*x1035*x1080))+(((-1.0)*x1047*x1048))+(((-0.03)*x1033*x1055))+(((-0.206)*r02*x1038))+(((-1.0)*x1050*x1068)));
evalcond[7]=((((0.00206)*x1032))+(((-1.0)*x1047*x1069))+(((-1.0)*x1063*x1072))+(((-1.0)*x1033*x1053))+((x1044*x1067))+(((0.03)*x1042*x1044))+((sj1*x1030*x1032))+(((-1.0)*pz*x1032*x1036))+(((-1.0)*x1030*x1035*x1047))+((x1030*x1061))+(((-0.028028)*x1076))+(((0.00309)*x1041))+(((-0.02)*r01*x1033))+(((0.00206)*x1047))+(((-0.02)*r02*x1045))+(((0.206)*x1060))+(((-0.010284)*x1061))+(((-1.0)*x1037*x1059))+(((-1.0)*r01*x1039*x1052))+(((-0.030053)*cj4*x1071))+(((-2.0)*px*x1033*x1044))+(((0.206)*x1046))+((x1032*x1075))+(((-1.0)*x1041*x1067))+((px*x1057*x1068))+(((-0.03)*x1052*x1055))+(((-1.0)*cj1*x1037*x1039))+(((-1.0)*pz*x1036*x1047))+(((-2.0)*sj0*x1033*x1037))+(((-0.03)*x1041*x1042))+((x1036*x1070))+(((-0.00309)*x1044))+(((-1.0)*x1029*x1032*x1035))+(((-1.0)*x1034*x1080))+(((-1.0)*x1039*x1055*x1056))+(((0.206)*x1037))+((x1029*x1061))+(((0.03)*sj1*x1050))+(((-1.0)*x1033*x1039*x1057))+(((-1.0)*x1032*x1069))+((r02*x1036*x1038))+((x1047*x1075))+((x1047*x1077)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
    }
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - marm (d70cc56b17336f89f60c342ccbb5791b)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
